\section{Introduction}

% 1. Describe the problem % 2. State your contributions
Mutation analysis is a method for evaluating the quality of test suites. It
involves producing a family of \emph{mutants}, programs with small
differences from the original program, and evaluating the
effectiveness of test suites against these
mutants~\cite{lipton1971fault, ammann2008introduction}.  Andrews et. al 
~\cite{andrews2005mutation} suggest mutations can simulate
behavior of real faults.
% thus
% introduced behave in a fashion similar to real faults, with respect to
% the difficulty of detection.

An impediment to the wider adoption of mutation analysis is its
high computational cost.  The set of simple mutants for even a
moderate sized program can be very large, making mutation
analysis prohibitively time consuming.

A major strain of research into cost-reduction of mutation analysis is
to choose a smaller, representative set of
mutants~\cite{offutt2001mutation,jia2011analysis} --- often called the
\textit{do fewer} approach. This approach can be generally divided
into selective strategies and sampling strategies.

Selective mutation strategies attempt to select a representative
subset of mutation \emph{operators} based on heuristics and
statistical analysis, and apply this subset of operators to generate
mutants instead of applying the whole set of mutation
operators~\cite{offutt1993anexperimental,untch2009onreduced}.
Recent work suggests that using statement deletion alone can
be an effective approach~\cite{untch2009onreduced}.

Sampling strategies seek to randomly select a set of representative
mutants.  This was investigated first by
Acree~\cite{acree1980mutation} and Budd~\cite{budd1980mutation}, who
proposed using only $x$\% of all mutants produced. Wong and Mathur
found that random sampling with ratio as low as 10\% could provide
accurate results~\cite{jia2011analysis}.

Recent work~\cite{zhang2010icse,zhang2013ase} has investigated the
relative merits of random sampling strategies and operator selection.
Random sampling can perform as well as or better than operator
selection, in these studies; and a strategy of either sampling based on
program elements or one combining both program element-based sampling
and operator selection was best.


However, as pointed out by Zhang et al.~\cite{zhang2013ase}, the field
has a serious lacuna in large scale research, both in the size of the
programs studied, and in the number and diversity of programs, which
reduces our confidence in all results. This is true for selective
mutation studies, sampling studies, and also for comparatively
newer studies that attempt to combine methods. This is particularly
worrisome if mutation analysis is to gain wider acceptance among
testing professionals. Further, quite a few of the influential
studies~\cite{offutt1993experimental,offutt1996anexperimental,wong1995reducing,mresa1999efficiency}
were conducted on older programming languages such as Fortran, with
operators specific to the language, and are not directly applicable to
newer languages such as Java. Finally, with bytecode~\footnote{
A \textit{do faster} approach for eliminating
the compilation step to gain execution speed
} based mutation
engines like PIT~\cite{pitest} and Javalanche~\cite{javalanche}
, operators based on
source code modification are no longer applicable, and their
equivalents in bytecode need to be identified and compared with other
approaches. A detailed discussion of these issues can be found in
Section~\ref{sec:related}.


We have attempted to rectify this situation with a large scale study of real
world programs. As detailed in Section~\ref{sec:methodology}, we sample
250 Java programs from Github\footnote{Our dataset is 322 programs, but as of
this writing the larger projects have not completed finished running
full-mutation analysis.},
with size ranging from 50 LOC to 100 KLOC, excluding tests,
which allow widely applicable statistical inferences to be made.

For a mutation selection strategy to be considered effective, especially during
the development, it should be able to expose as many defect-like behaviors as
possible.


Section~\ref{sec:methodology} discusses the sampling and operator
selection strategies we study in detail, and the results of our
experiment are given in Section~\ref{sec:results}, followed by
detailed discussion of what these results imply in Section
~\ref{sec:discussion}. The specific contributions of this paper are:

\begin{itemize}

\item Our study is the largest so far in terms of
both the size of programs involved (50 LOC to 100 KLOC excluding tests),
and the number of programs analyzed (250 unique open source projects) for
mutant reduction strategies. This allows for stronger and more widely
applicable conclusions about effectiveness.

\item We compare a much larger
number of mutant reduction strategies than previous studies. Our reduction
strategies include all the common and influential strategies for
random sampling, element scoped sampling, and operator selection, that
have been proposed in previous studeies.

\item Our evaluation crtieria is applicable to non-adequate test suites
which makes the results immediately relevant for real world programs with
non-adequate test suites.

\item Most importantly, we find that current operator reduction strategies
seldom perform better than random sampling of mutants, which suggests a need
for further research in this area.

\end{itemize}

