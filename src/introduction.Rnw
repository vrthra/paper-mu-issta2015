\section{Introduction}

% 1. Describe the problem % 2. State your contributions
Mutation analysis is a method for evaluating the quality of test suites. It
involves producing a family of \emph{mutants}, programs with small
differences from the original program, and evaluating the
effectiveness of test suites against these
mutants~\cite{lipton1971fault, ammann2008introduction}.  Previous
research~\cite{andrews2005mutation} suggests that mutations thus
introduced behave in a fashion similar to real faults, with respect to
the difficulty of detection.

One of the impediments to wider adoption of mutation analysis is its
high computational cost.  The set of simple mutants for even a
moderate sized program can be very large, making mutation
analysis prohibitively time consuming.

A major strain of research into cost-reduction of mutation analysis is
to choose a smaller, representative, set of
mutants~\cite{offutt2001mutation,jia2011analysis} --- often called the
\textit{do fewer} approach. This approach can be generally divided
into selective strategies and sampling strategies.

Selective mutation strategies attempt to select a representative
subset of mutation \emph{operators} based on heuristics and
statistical analysis, and apply this subset of operators to generate
mutants instead of applying the whole set of mutation
operators~\cite{offutt1993anexperimental,untch2009onreduced}.
Recent work suggests that using statement deletion alone can
be an effective approach~\cite{untch2009onreduced}.

Sampling strategies seek to randomly select a set of representative
mutants.  This was investigated first by
Acree~\cite{acree1980mutation} and Budd~\cite{budd1980mutation}, who
proposed using only $x$\% of all mutants produced. Wong and Mathur
found that random sampling with ratio as low as 10\% could provide
accurate results~\cite{jia2011analysis}.

Recent work~\cite{zhang2010icse,zhang2013ase} has investigated the
relative merits of random sampling strategies and operator selection.
Random sampling can perform as well as or better than operator
selection, in these studies; and a strategy of either sampling based on
program elements or one combining both program element-based sampling
and operator selection was best.

However, as pointed out by Zhang et al.~\cite{zhang2013ase}, the field
has a serious lacuna in large scale research, both in the size of the
programs studied, and in the number and diversity of programs, which
reduces our confidence in all results. This is true for selective
mutation studies, sampling studies, and also for comparatively
newer studies that attempt to combine methods. This is particularly
worrisome if mutation analysis is to gain wider acceptance among
testing professionals. Further, quite a few of the influential
studies~\cite{offutt1993experimental,offutt1996anexperimental,wong1995reducing,mresa1999efficiency}
were conducted on older programming languages such as Fortran, with
operators specific to the language, and are not directly applicable to
newer languages such as Java. Finally, with bytecode based mutation
engines like PIT~\cite{pitest} and Javalanche~\cite{javalanche}
(a \textit{do faster} approach for eliminating
the compilation step to gain execution speed), operators based on
source code modification are no longer applicable, and their
equivalents in bytecode need to be identified and compared with other
approaches. A detailed discussion of these issues can be found in
Section~\ref{sec:related}.

We have attempted to rectify this situation with a large scale study of real
world programs.  As detailed in Section~\ref{sec:methodology}, we sample
188 Java programs from Github, with size ranging from 50 LOC to 100 KLOC,
which should allow widely applicable statistical inferences to be made. We
provide the results from running both the original project's (presumably
human-generated) test suites and also automatically generated test suites
using random testing, increasing the applicability of our findings to both
testers in traditional development who are interested in applying mutation
analysis to suite evaluation and to researchers who seek to compare test
suites quickly to evaluate testing techniques.

One note about our, and other researchers, evaluation criteria is in
order.  We, like others, use the ability of a sample to correlate well
to the score over all mutants as a measure of sampling quality.  The
underlying reason for this is that, while many mutants have little
ability to distinguish between good and bad test suites, some smaller
set of mutants show subtle deficiencies in suites that are not clear
from, say, code coverage.  The full set of mutants obviously contains
these mutants, and correlating with (rather than matching) the
full mutation score is a strong indicator that many of these
discriminatory mutants have been preserved in a sample.

Section~\ref{sec:methodology} discusses the sampling and operator
selection strategies we study in detail, and the results of our
experiment are given in Section~\ref{sec:results}, followed by
detailed discussion of what these results imply in Section
~\ref{sec:discussion}. The specific contributions of this paper are:

\begin{itemize}

\item Our study is the largest so far in terms of both the size of programs
involved (50 LOC to 100 KLOC), and the number of programs analyzed (188
unique open source projects) for mutant reduction strategies. This allows
for stronger and more widely applicable conclusions about effectiveness.

\item We compare a much larger number of mutant reduction strategies
than previous studies. We compare with respect to the predictive power
(correlation with the full mutation score), expected mutant reduction,
and the stability of the amount of mutant reduction expected. Our
sampling strategies include some that were suggested by other
researchers, as well as a few novel strategies not previously considered.

\item Our recommendations are useful for both testing researchers who
might be comparing automatically generated test suites, and software
testers in real world working to produce and evaluate manual test suites.

\item Most importantly, we find that random sampling strategies perform
better than operator selection strategies in consistently predicting the
final mutation score while obtaining stable computational reduction.

\end{itemize}

Our data will be available for replication on publication~\cite{data}
%\footnote{Available on publication}.

