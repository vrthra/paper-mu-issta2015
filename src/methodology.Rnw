\section{Methodology} \label{sec:methodology} Our selection of
programs was driven by a few overriding concerns. Our primary
requirement was that our results had to be as widely applicable as
possible for real-world programs. Secondly, we strived for a
statistically significant result, reducing the number of variables
present in the experiments. For this reason we chose a random sample
of Java projects from Github~\cite{github} and Apache Software
Foundation~\cite{apache} that use the popular
maven~\cite{maven} build system, following the methodology we used
previously in an ICSE 2014 paper~\cite{gopinath2014code}.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are
limited, we extended PIT to provide newer operators that are similar to
operators provided by other mutation systems. The set of operators that
we used is provided in Table~\ref{tbl:pitop}.
% Figure~\ref{fig:op} shows
% the distribution of mutants and the relative detection rates of each
% mutation operator for our projects. In the figure, there are two box-plots
% corresponding to each mutation operator on the Y-axis. The black box represents
% the relative frequency of the particular mutation operator in the total
% mutants \textit{produced}. For example, for projects in the (Randoop) generated set,
% the operator \pitnvmc contributed about 34\% of the total number of mutants
% produced while \pitrv contributed about 7\%. Similarly, the blue shaded
% box-plot represents the relative frequency of particular mutation operator
% in the total mutants \textit{detected}. For example, \pitnvmc contribution
% in the detected mutants was 23\% while that of \pitrv was 15\%.

For a detailed description of each mutation operator, please refer to PIT documentation~\cite{pitmut}.
We modified PIT to report the entire test matrix of $tests \times failures$
rather than just the first failure, and used this for our analysis. To remove
the effects of random noice, results of each criteria was averaged out of ten
runs.

\begin{table}
\small{
\begin{tabular}{ll}
\hline \hline \\
\pitin & Remove negative sign from numbers\\
\pitrv & Mutate return values\\
\pitm & Mutate arithmetic operators\\
\pitvmc & Remove void method calls\\
\pitnc & Negate conditional statements\\
\pitcb & Modify boundaries in logical conditions\\
\piti & Modify increment and decrement statements\\
\pitnvmc & Remove non-void method calls, returning default value \\
\pitcc & Replace constructor calls, returning null \\
\pitic & Replace inline constants with default value \\
\pitri & Remove increment and decrement statements \\
\pitemv & Replace member variable assignments with default value \\
\pites & Modify switch statements \\
\pitrs & Replace switch labels with default (thus removing them) \\
\pitrc & Replace boolean conditions with true\\
\pitnc & Replace boolean conditions with false\\
\hline
\end{tabular}
}
\caption{PIT Mutation Operators (We have used abbreviations instead of operator names.)}
\label{tbl:pitop}
\end{table}

\subsection{Sampling Criteria}

We used several different sampling criteria that has been mentioned in the
literature, For each sampling criteria, we sampled mutants on a decreasing
power scale, sampling \textit{1/2, 1/4, 1/8, 1/16, 1/32, 1/64} of the total
mutants.

\subsubsection{x\% selection}
The simplest sampling approach consisted of using x\% selection as suggested by
Budd~\cite{budd1980mutation}. In this criteria, we choose a specific
fraction of the complete set of mutants. This criteria also serves as a
baseline for verifying the effectiveness of other criteria.

\subsubsection{x\% selection per operator}
This strategy, first suggested by Wong et al.~\cite{wong1995reducing} samples an equal percentage
of mutants from each operator.

\subsubsection{Sampling over program elements}
Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we
extended x\% selection criteria to sample from within different program
elements.  We sampled in increasing order of scope,
--- \textit{line}, \textit{method} and \textit{class} (\textit{project}
scope is just x\% selection).

We used the formula by Zhang et al.~\cite{zhang2013ase},
\[sample(x) = \lfloor x + random(0..1) \rfloor \]
to correctly sample decimal numbers.

\subsection{Operator Selection}
For selective methods, we tried mutation operators
suggested by Wong et al.~\cite{wong1995reducing}, Offutt et
al.~\cite{offutt1996anexperimental,deng2013empirical}, and, Namin et
al.~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized
operator selection mechanisms, we also compared the Javalanche operators for
operator selection. Note that all of these techniques except Javalanche have
targeted C programs. Thus, some of these operators may be sensible in C but not
in Java. For example, deletion of return statement is tolerated in C,
not in Java.  Moreover, there were a few operators that were not supported
by the PIT, and could not be implemented easily (as mentioned below).

\subsubsection{Constrained Mutation}
\noindent\textbf{Wong et al. ~\cite{wong1995reducing}.}
They selected ROR  and ABS  from Mothra for
mutation analysis. We used operators
\pitcb and \pitnc to model ROR operator. There are no comparable operators to ABS in PIT.

\subsubsection{E-Selective}
\noindent\textbf{Offut et al. \cite{offutt1996anexperimental}.}
They selected ABS, UOI, LCR, AOR, ROR from Mothra operators.
We have used  \Pitin, \Pitm, \Pitcb, and \Pitnc. PIT does not have any operator
comparable to LCR.

\subsubsection{Javalanche}
\noindent\textbf{Javalanche \cite{javalanche}.}
Javalanche uses Negate Jump Condition, Omit Method
 Call, Replace Arithmetic Operator, and Replace Numerical
 Constant operators. We have used \Pitnc, \Pitvmc,
\Pitnvmc, \Pitm, \Pitic and \Pitemv to model them.

\subsubsection{Variable Reduction}
\noindent\textbf{Namin et al.~\cite{siami2008sufficient}.}
They have tried to reduce the mutation operators of Proteum analysis
tool which is for C programs. They suggest 28 operators which many of them
are not applicable in Java, and some not in PIT.
We  used by  \Pitin, \Pitm, \Piti, and \Pitnc.

\subsubsection{N-selection}
\noindent\textbf{Offut et al. ~\cite{offutt1993experimental}.} They suggested removal of
$n$ most numerous operators. In our experiment, the order of operators was
\Pitnvmc, \Pitrv, \Pitic, \Pitdc, \Pitnc, \Pitrc, \Pitvmc, \Pitcc, \Pitemv,
\Pitm, \Pitcb, \Piti, \Pitri, \Pitrs, \Pites, and \Pitin.
We discarded one at each
step and evaluated the effectiveness at each $n$.
%----------------------------------------
\subsubsection{Statement Deletion} \label{subsec:stmtdel} The basic
statement deletion was modeled on the work by Deng et
al.~\cite{deng2013empirical}. The operations on single statements were
modeled using \Pitvmc, \Pitnvmc, \Pitcc, \Pitemv, and \Pitri~for
simple statements, and using \pitrc for control structures. \pitrc
replaces boolean conditions with \textit{false}, resulting in removal of the
conditional block. The operator for return values was modeled using
\Pitrv, which is similar.  The operators for \textit{while},
\textit{for}, and \textit{if} statements were modeled using \Pitdc,
which replaced the boolean condition with \textit{true}, which removed the
effect of conditional. The \textit{switch} statement deletion was
modeled using \pitrs which replaced the first 100 labels with a
\textit{default} label, resulting in the switch element being
deleted. Due to the constraints of the architecture of PIT only the
first 100 labels were replaced. Deleting \textit{try/catch} was not
necessary at bytecode level.  Finally, to get an accurate estimation
of the effect of true statement deletion, we grouped the mutants by
line, and considered each line a single virtual mutant (that is, the total
number of mutants is equal to the total number of lines). Further,
killing any mutant from a line resulted in marking the virtual mutant
for that line as killed. This gave us the mutation score for the
virtual statement deletion operator.  We note that the approximation
of simple statement deletion, especially when arithmetic operators are
involved, is not complete. However,
the number of mutants produced by \pitm operator is very small. We
also note that our approximation does not account for the increase in
ease of detection when multiple mutations are combined together due to
the coupling effect. This also means that not all the lines may be
mutated ,since there may be no applicable operators. However, given
the constraints of a bytecode based mutation system, we believe that
our procedure is reasonable.
% An interesting point is that using this
%procedure statement, deletion is no longer a simple mutation and
%qualifies as a higher order mutation operator. In fact, the procedure
%we outlined can be used in general to judge the effectiveness of a
%higher order operator from the results of the first order mutation
%operators that together compose the higher order mutant.

