\begin{figure*}
<<op,fig.width=10, fig.height=5, out.width='.95\\linewidth', out.heigth='4in', echo=F, message=F, warn=F,fig.lp="fig:">>=
clean <- function(x) {
  sub('CONSTRUCTOR_CALLS','CC',
      sub('INCREMENTS','I',
        sub('RETURN_VALS','RV',
          sub('VOID_METHOD_CALLS','VMC',
            sub('NON_VOID_METHOD_CALLS','NMC',
              sub('RMSWITCH','RS',
                sub('REMOVE_CONDITIONALS','RC',
                  sub('REMOVE_INCREMENTS','RI',
                    sub('NEGATE_CONDITIONALS','NC',
                      sub('MATH','M',
                        sub('INVERT_NEGS','IN',
                          sub('INLINE_CONSTS','IC',
                            sub('EXPERIMENTAL_SWITCH','ES',
                              sub('EXPERIMENTAL_MEMBER_VARIABLE','EMV',
                                sub('DELETE_CONDITIONALS','DC',
                                  sub('CONDITIONALS_BOUNDARY','CB',x))))))))))))))))
}
par(las=1,mfrow = c(1, 2),mar=c(2,8,1,1))
o.all <- cbind(projects = rownames(o.dist.all), stack(o.dist.all))
o.all$ind <- clean(o.all$ind)
bcol <- '#2171B5'
#bcol <- 'darkgray'
icol <- '#9ECAE0'
#icol <- 'lightgray'
o.det <- cbind(projects = rownames(o.dist.det), stack(o.dist.det))
o.det$ind <- clean(o.det$ind)
with(o.all,boxplot(values~ind,horizontal=T,border=c(bcol), pch='.', axes=F, ylim=c(0,0.6), col=icol ))
with(o.det,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Original', cex.axis=0.8, ylim=c(0,0.6),add=T))

r.all <- cbind(projects = rownames(r.dist.all), stack(r.dist.all))
r.all$ind <- clean(r.all$ind)
r.det <- cbind(projects = rownames(r.dist.det), stack(r.dist.det))
r.det$ind <- clean(r.det$ind)
with(r.all,boxplot(values~ind,horizontal=T,border=c(bcol), pch='.', axes=F,ylim=c(0,0.6),  col=icol))
with(r.det,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Randoop', cex.axis=0.8,ylim=c(0,0.6),add=T))
@
\caption{The relative contribution of mutation operators in terms of fraction of mutants generated and detected.
The blue shade represent detected mutants, while black represents total mutants.}
\label{fig:op}
\end{figure*}

\section{Methodology} \label{sec:methodology} Our selection of
programs was driven by a few overriding concerns. Our primary
requirement was that our results had to be as widely applicable as
possible for real-world programs. Secondly, we strived for a
statistically significant result, reducing the number of variables
present in the experiments. For this reason we chose a random sample
of Java projects from Github~\cite{github} that use the popular
maven~\cite{maven} build system, following the methodology we used
previously in an ICSE 2014 paper~\cite{gopinath2014code}. As in that
work, we utilize two kinds of of test suites: the original test suites
present in a limited number of projects, and automatically generated
test suites from Randoop~\cite{randoop}.  Due to limited resources, we
had to further reduce the programs and test suites to those that could
finish mutation analysis in 10 minutes. From this set of test suites,
we sampled 110 suites each for both original and Randoop generated
test suites. Since there was some overlap between projects with
original test suites, and those with Randoop test suites, we had 81
unique projects each in both sets. The remaining projects had both
flavors of test suites.  % {\bf ADG I have no idea what that last
sentence means, really.  % RG: Fixed}

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are limited,
we extended PIT to provide newer operators that are similar to operators
provided by other mutation systems. The set of operators that we used
is provided in Table~\ref{tbl:pitop}. Figure~\ref{fig:op} which shows both the
distribution of mutants and the relative detection rates of each
mutation operator for our projects. In the figure, there are two box-plots corresponding
to each mutation operator on the Y-axis. The black box represents the
relative frequency of the particular mutation operator in the total mutants
\textit{generated}. For example for projects in the Randoop set, the
operator \pitnvmc contributed about 34\% of the total number of mutants
produced while \pitrv contributed about 7\%. Similarly, the blue shaded
box-plot represents the relative frequency of particular mutation operator
in the total mutants \textit{detected}. For example, \pitnvmc contribution
in the detected mutants was 23\% while that of \pitrv was 15\%.

For a detailed description of each mutant type, please see~\cite{pitmut}.
PIT was also modified to provide random selection of mutants according
to various criteria. Finally, to remove random noise, each criteria
described was run four times, and the results averaged to produce
the final result.

\begin{table}
\small{
\begin{tabular}{ll}
\hline \hline \\
\pitin & Remove negative sign from numbers\\
\pitrv & Mutate return values\\
\pitm & Mutate arithmetic operators\\
\pitvmc & Remove void method calls\\
\pitnc & Negate conditional statements\\
\pitcb & Modify boundaries in logical conditions\\
\piti & Modify increment and decrement statements\\
\pitnvmc & Remove non-void method calls, returning default value \\
\pitcc & Replace constructor calls, returning null \\
\pitic & Replace inline constants with default value \\
\pitri & Remove increment and decrement statements \\
\pitemv & Replace member variable assignments with default value \\
\pites & Modify switch statements \\
\pitrs & Replace switch labels with default (thus removing them) \\
\pitrc & Replace boolean conditions with true\\
\pitnc & Replace boolean conditions with false\\
\hline
\end{tabular}
}
\caption{PIT Mutation Operators (We have used abbreviations instead of operator names.)}
\label{tbl:pitop}
\end{table}


One of the criteria we sampled was \textit{statement deletion}.
Since we use PIT, which is a bytecode based mutation engine, implementing direct equivalent of
source code statement deletion is very hard. We were able to approximate statement deletion
by combining different bytecode operators, as explained in Subsection~\ref{subsec:stmtdel}.

\subsection{Sampling Criteria}

We used several different sampling criteria, some of which has been suggested
in the literature before, some of which are variants of previously suggested
criteria, and some of which have not been used before.  For each sampling
criteria, we sampled mutants on a decreasing power scale, sampling
\textit{1, 1/2, 1/4, 1/8, 1/16, 1/64} of the total mutants.

\subsubsection{x\% selection}
The simplest sampling approach consisted of using x\% selection as suggested by
Budd~\cite{budd1980mutation}. In this criteria, we choose a specific
fraction of the complete set of mutants. This criteria also serves as a
control for verifying the effectiveness of other criteria.

\subsubsection{Sampling over program elements (and variations)}
Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we
extended x\% selection criteria to sample from within different program
elements.  We sampled in increasing order of scope,
--- \textit{line}, \textit{method} and \textit{class} (\textit{project}
scope is just x\% selection).

When the number of mutants to be chosen was not a whole number, we used
the formula suggested by Zhang et a.~\cite{zhang2013ase}, and used the
decimal part to select a mutant with that probability.

Next, we modified this criteria slightly, and instead of choosing a
mutant with probability equal to the decimal part, we applied
\textit{round(sample)} to round it to the nearest whole number. We
used this as the number of samples to be chosen from the
population. Our aim was to \emph{remove} elements that were too simple. That
is, if the number of mutants dropped below a threshold determined by
the mutant reduction ratio, that program element did not contribute
any mutants to the final result.  Conceptually the idea is that mutants of more complex code have more discriminatory power (and may correspond better to real faults though we do not evaluate this concept).

Next, we explored in the other direction, by forcing the program elements
to return at least one element by using \textit{ceil(sample)}. That is,
irrespective of the fraction being sampled, the simplest elements always
contributed at least one mutant to the total sample.

\subsubsection{Lines per element and variants}
Our previous research~\cite{gopinath2014code} found that statement coverage
was highly correlated with mutation score for a project. This immediately
suggests that perhaps choosing one mutant per line may be sufficient to achieve
a close approximation of the final mutation score. Further, statement deletion
has been researched previously~\cite{untch2009onreduced,deng2013empirical} and
has been found to reduce the number of mutants well, without an appreciable
decrease in accuracy. This also provides a nice comparison with similar
numbers of mutants between operator selection and random sampling of mutants.

We next extended this approach to sample from each method instead, but
used the number of lines in the method as the number of mutants to be
sampled from it. This provided a test of the hypothesis of how
important a mutation sampling's relationship to simple code coverage
was. This was extended to class and project scope also.

For the first variant, we applied the x\% sampling to the result of
the first sampling based on line counts. That is, in the case of
methods, we first selected \textit{linecount} mutants each from each
method, and applied the x\% selection to the result of this
selection. For example, for $1/2$ sampling on methods if one method had
$10$ lines and another had $20$ lines, we sampled $10$ mutants from
the first, and $20$ mutants from the second, and from the combined
$30$ mutants, we sampled $15$.  For the second variant, we did the
sampling in one go, where we chose \textit{linecount/x} number of
mutants from each program element.  That is, in the previous example,
only $5$ mutants from the first and $10$ mutants from the second
method would be chosen.

%{\bf ADG:  Could maybe make this clearer?}
% RG: Fixed with an example.

\subsubsection{One per element}
Another simple strategy of sampling we experimented with is to just choose
one mutant per program element, in the order \textit{line}, \textit{method}, \textit{class}.

\subsubsection{x\% selection per operator}
This strategy, first suggested by Wong et al.~\cite{wong1995reducing} samples an equal percentage
of mutants from each operator.

\subsection{Operator Selection}

For selective methods, we tried mutation operators suggested by Wong et al.~\cite{wong1995reducing}, Offutt et al.~\cite{offutt1996anexperimental,deng2013empirical}, % TODO Barbosa
 and, Namin et al~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized operator selection mechanisms, we also compared the Javalanche operators for operator selection. Note that all of these techniques except 
Javalanche have targeted C programs, thus some of these operators
are sensible in C but not in Java programs. For example C compilers tolerate
removing a return statement --- but in Java this causes a compilation error.
Moreover, there were some operators that are not supported by the PIT framework
like ABS (absolute mutation operators). We tried to realize as many
as possible of the operators using PIT's bytecode level mutation. We also extended 
the PIT framework to support the  statement deletion operator (SDL).


% {\bf Amin: The rest of this section is for Alex and Carlos info and should be verified if we should include this or wave our hands about approximation instead.}

\subsubsection{Criteria I}
For this criteria, we used the two operators \pitcb and \pitnc which are similar to those given by Wong. We did not have ABS operator available in PIT.
\subsubsection{Criteria II}
We used the operators given by Offutt et al. \pitin, \pitm, \pitcb, \pitnc. We did not have LCR available in PIT.
\subsubsection{Criteria III}
Those given by Javalanche \pitnc, \pitvmc, \pitnvmc, \pitm, \pitic, \pitemv. 
\subsubsection{Criteria IV}
Namin et al. used \pitin, \pitm, \piti, \pitnc. Many of these operators were not applicable in Java, and some were not available in PIT (e.g. IndVarBitNeg).
\subsubsection{Criteria V}
For this criteria, we utilized the approach suggested by
Offutt et al.~\cite{offutt1993experimental} where the most numerous operators
are discarded at each step.

\subsubsection{Statement Deletion:} \label{subsec:stmtdel} The basic
statement deletion was modeled on the work by Deng et
al.~\cite{deng2013empirical}. The operations on single statements were
modeled using \pitvmc, \pitnvmc, \pitcc, \pitemv, and \pitri for
simple statements, and using \pitrc for control structures, which
replaced the boolean condition with false, resulting in removal of the
block of statements. The operator for return values was modeled using
\pitrv, which is similar.  The operators for \textit{while},
\textit{for}, and \textit{if} statements were modeled using \pitdc,
which replaced the boolean condition with true, which removed the
effect of conditional. The \textit{switch} statement deletion was
modeled using \pitrs which replaced the first 100 labels with a
\textit{default} label, resulting in the switch element being
deleted. Due to the constraints of the architecture of PIT only the
first 100 labels were replaced. Deleting \textit{try/catch} was not
necessary at bytecode level.  Finally, to get an accurate estimation
of the effect of true statement deletion, we grouped the mutants by
line, and considered a single virtual mutant (that is, the total
number of mutants is equal to the total number of lines). Further,
killing any mutant from a line resulted in marking the virtual mutant
for that line as killed. This gave us the mutation score for the
virtual statement deletion operator.  We note that the approximation
of simple statement deletion, especially when arithmetic operators are
involved, is not complete. However, as seen in Figure~\ref{fig:op},
the number of mutants produced by \pitm operator is very small. We
also note that our approximation does not account for the increase in
ease of detection when multiple mutations are combined together due to
the coupling effect. This also means that not all the lines may be
mutated ,since there may be no applicable operators. However, given
the constraints of a bytecode based mutation system, we believe that
our procedure is reasonable. An interesting point is that using this
procedure statement deletion is no longer a simple mutation and
qualifies as a higher order mutation operator. In fact, the procedure
we outlined can be used in general to judge the effectiveness of a
higher order operator from the results of the first order mutation
operators that together compose the higher order mutant.

