\section{Methodology}
\label{sec:methodology}
Our selection of programs was driven by a few overriding concerns. Our primary
requirement was that, our results had to be as widely applicable as possible
for real-world programs. Secondly, we strived for a statistically significant
result, reducing the amount of variables present in the experiments. For this
reason we chose a random sample of Java projects from Github\cite{github}
that uses the popular maven\cite{maven} build system, that has been used
elsewhere\cite{gopinath2014code}. This set of projects comes in two flavors
of test-suites. The original test-suites present in a limited number of
projects, and automatically generatd test-suites using randoop.  Due to the
constraints in resources, we had to further reduce the programs and test-suites
to those that could finish the mutation run in 10 minutes. From this set
of test-suites, we sampled 110 suites each for both original and randoop
generated test-suiets. This gave us 81 unique projects for both original
and randoop, and remaining projects having both flavors of test suites.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are limited,
we extended PIT to provide newer operators that are similar to operators
provided by other mutation systems. The set of operators provided by PIT
are provided in Table~\ref{tbl:pitop}.

Further, we also modified PIT to provide random selection of mutants according
to various criterias.

<<opstable,results='asis'>>=
op=c(
'INVERT-NEGS',
'RETURN-VALS',
'MATH',
'VOID-M-CALLS',
'NEGATE-COND',
'COND-BOUNDARY',
'INCREMENTS',
'NVOID-M-CALLS',
'CONSTR-CALLS',
'INLINE-CONSTS',
'RM-INCR',
'E-MEMBER-VAR',
'E-SWITCH',
'RM-SWITCH',
'RM-COND',
'DELETE-COND')
expl=c(
'Invert negatives',
'Change return values',
'Modify arithmetic operators',
'Remove void method calls',
'Negate conditional statements',
'Modify boundary conditions',
'Modify increment/decrement',
'Replace non-void method calls',
'Replace constructor calls',
'Replace inline constants',
'Remove increment/decrement',
'Replace member variable assignments',
'Modify switch statements',
'Remove switch elements*',
'Make conditionas true',
'Make conditionas false*')
op.df <- data.frame(Operator=op, Explanation=expl)
print(xtable(op.df,caption='PIT Mutation Opeators (* indicates new opeators)', label='tbl:pitop'), sanitize.text.function  = function(x){x}, include.colnames=FALSE, include.rownames=F)
@

One of our research questions was to compare the utility of operator
selection --- especially statement deletion --- with random sampling of mutants,
Since we use PIT, which is a bytecode oriented mutation engine, implementing statement deletion
directly is very hard. However, we can approximate statement deletion by combining different
bytecode operators, as given below.

The basic statement deletion was mdeled on the work by Deng et al.~\cite{deng2013empirical}. The operations
on single statements was modeled using \textit{VOID-M-CALLS,NONV-M-CALLS,CONSTR-CALLS,E-MEMBER-VAR,RM-INCR} for simple statements, and using \textit{RM-COND} for control structures, which replaced the boolean condition with false, resulting in removal of the block of statements. The operator for return values was modeled using \textit{RETURN-VALS}, which is similar.
The operators for \textit{while,for}, and \textit{if} statements were modeled using \textit{DELETE-COND}, which replaced the boolean condition with true, which removed the effect of conditional. The \textit{switch} statement deletion was modeled using \textit{RM-SWITCH} which replaced the first 100 labels with default label, resulting in the switch element getting deleted. (Due to the constraints of the architecture of PIT only the first 100 labels were replaced). The \textit{try catch} was not necessary at bytecode level.
Finally, to get an accurate estimation of the effect of true statement deletion, we grouped the mutants by line, and considered a single virtual mutant (That is, the total number of mutants is equal to the total number of lines). Further, killing any mutant from a line resulted in marking the virtual mutant for that line as killed. This gave us the mutation score for the virtual statement deletion operator.
We note that the approximation of simple statement deletion, especially when arithmetic operators are involved is not complete. However, as seen in Figure~\ref{fig:op}, the number of mutants produced by \textit{MATH} operator is very small. We also note that our approximation does not account for the increase in ease of detection when multiple mutations are combined together due to coupling effect. This also means that not all the lines may be mutated since there may be no applicable operators. However, given the constraints of a bytecode based mutation system, we believe that our procedure is reasonable.

\subsection{Sampling Criterias}

We used several different sampling criterias.

\subsubsection{x\% selection}
The simplest one consisted of using x\% selection as suggested by Wong et al.~\cite{wong1995reducing}. In this criteria, we choose a specific fraction of the complete mutants. Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we extend this criteria to sample mutants from within different program elements. We sampled x\% selection in the increasing order of scope, --- \textit{line}, \textit{method}, \textit{class}, and \textit{project} --- and decreasing fraction of total mutants -- \textit{1, 1/2, 1/4, 1/8, 1/16, 1/64}.

While the sampling criteria is simple, it is not immediately clear when we are faced with program elements that produced too few mutants for a particular fraction to yield at-least one mutant. For example, for a line that produced 15 mutants, the number of mutants that can be chosen in \textit{(x\%, line, 1/64)} is less than 1. We analyzed the results of the following criterias: 1) to round the resulting number to the nearest integer, and choose that value as sampling (in effect, ignoring elements that are less complex), 2) to apply \textit{ceil} function to the resulting value, ensuring that there is atleast one mutant per program element, and 3) to perform the sampling in such a way that it chooses a mutant with with the fractional probability (this is the method followed by Zhang et al.~\cite{zhang2013ase}).
% TODO: If the criterias ceil and round does not make sense, we might remove them to gain space.

\subsubsection{Lines per element}
Our previous research~\cite{gopinath2014code} found that statement coverage was highly correlated with mutation coverage for a project. This immediately suggests that perhaps choosing one mutant per line may be sufficient to achieve a close approximation of the final mutation score. Further, statement deletion has been researched previously~\cite{untch2009onreduced,deng2013empirical} and has been found to reduce the number of mutants well, without an appreciable decrease in accuracy. This also provides a nice comparison with similar number of mutants between operator selection and random sampling of mutants.

A simple extension of this approach is to extend this strategy as previously, by choosing as many number of mutants as there are number of lines in a program element, and we can extend it as before to sample \textit{1/2,1/4,1/8,1/16,1/32,1/64} of the mutants thus chosen. We chose the rounding strategy for fractional samples for simplicity.
% TODO: Actually do the other rounding choices.

Here too, we have a few choices when sampling mutants. We could either choose the fraction of mutants within the program element, or we could apply the sampling externally. For example, using $\lambda_E$ as number of lines in an element, for \textit{(lpe, $1/2$, method)}, we first get $1/2 \times \lambda_{Method}$ number of mutants from each method. The second alternative is to get $\lambda_{Method}$ number of mutants for all methods, then from this larger set, choose only half of the mutants.

\subsubsection{One per element}
An extremely simple strategy of sampling is to just choose one mutant per program element, which as before, we extended to include all the fractions \textit{1/2,1/4,1/8,1/16,1/32,1/64}.

\subsection{Operator Reduction}
% TODO expand as required

For operator reduction, we utilized the constrained mutation operators suggested by Wong et al.~\cite{wong1995reducing}, Offutt et al.~\cite{offutt1996anexperimental,deng2013empirical}, % TODO Barbosa
 and, Namin et al~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized operator selection mechanisms, we also compared the Javalanche operators for operator selection.

\subsubsection{Constrained Mutation}
For this criteria, we used the two operators \textit{COND\_BOUNDARY, and NEGATE\_COND} which are similar to those given by Wong.
\subsubsection{Operator Selection}
We used the operators given by Offutt et al. \textit{INVERT\_NEGS, MATH, COND\_BOUNDARY,} \textit{NEGATE\_COND}, those given by Javalanche \textit{NEGATE\_COND, VOID\_METHOD\_CALLS, NON\_VOID\_METHOD\_CALLS, MATH, INLINE\_CONSTS, E\_MEMBER\_VARIABLE},  and by Namin et al.\textit{INVERT\_NEGS, MATH, INCREMENTS, NEGATE\_COND}. We also  compare N-Selective mutation as suggested by Offutt et al.

\subsection{Mutant Clustering}
For mutant clustering, we were unable to directly apply clustering based on distinct mutants as suggested by Hussain~\cite{hussain2008mutation}. However, we were able to apply clustering techniques on mutation operators, thus turning it to a set of selected operators.
