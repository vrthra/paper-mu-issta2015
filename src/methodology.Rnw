\begin{figure*}
<<op,fig.width=10, fig.height=5, out.width='.95\\linewidth', out.heigth='4in', echo=F, message=F, warn=F,fig.lp="fig:">>=
par(las=1,mfrow = c(1, 2),mar=c(2,8,1,1))
o.all <- cbind(projects = rownames(o.dist.all), stack(o.dist.all))
o.all$ind <- clean(o.all$ind)
bcol <- '#2171B5'
#bcol <- 'darkgray'
icol <- '#9ECAE0'
#icol <- 'lightgray'
o.det <- cbind(projects = rownames(o.dist.det), stack(o.dist.det))
o.det$ind <- clean(o.det$ind)
with(o.all,boxplot(values~ind,horizontal=T,border=c(bcol), pch='.', axes=F, ylim=c(0,0.6), col=icol ))
with(o.det,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Original', cex.axis=0.8, ylim=c(0,0.6),add=T))

r.all <- cbind(projects = rownames(r.dist.all), stack(r.dist.all))
r.all$ind <- clean(r.all$ind)
r.det <- cbind(projects = rownames(r.dist.det), stack(r.dist.det))
r.det$ind <- clean(r.det$ind)
with(r.all,boxplot(values~ind,horizontal=T,border=c(bcol), pch='.', axes=F,ylim=c(0,0.6),  col=icol))
with(r.det,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Randoop', cex.axis=0.8,ylim=c(0,0.6),add=T))
@
\caption{The relative contribution of mutation operators in terms of fraction of mutants generated and detected.
The blue shade represent detected mutants, while black represents total mutants.}
\label{fig:op}
\end{figure*}

\section{Methodology}
\label{sec:methodology}
Our selection of programs was driven by a few overriding concerns. Our primary
requirement was that, our results had to be as widely applicable as possible
for real-world programs. Secondly, we strived for a statistically significant
result, reducing the amount of variables present in the experiments. For this
reason we chose a random sample of Java projects from Github\cite{github}
that uses the popular maven\cite{maven} build system, that has been used
elsewhere\cite{gopinath2014code}. We utilize two flavors of
of test-suites. The original test-suites present in a limited number of
projects, and automatically generatd test-suites using randoop.  Due
limited resources, we had to further reduce the programs and test-suites
to those that could finish the mutation run in 10 minutes. From this set
of test-suites, we sampled 110 suites each for both original and randoop
generated test-suiets. This gave us 81 unique projects for both original
and randoop, and remaining projects having both flavors of test suites.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are limited,
we extended PIT to provide newer operators that are similar to operators
provided by other mutation systems. The set of operators that we used
are provided in Table~\ref{tbl:pitop}. A distribution of these operators
in our projects are provided in Figure~\ref{fig:op}, which shows both the
distribution of complete mutants and the relative detection rates of each
mutation operators. In the figure, there are two box-plots corresponding
to each mutation operator on the Y-axis. The black box represents the
relative frequency of the particular mutation operator in the total mutants
\textit{generated}. For example for projects in the randoop set, the
operator \pitnvmc contributed about 34\% of the total number of mutants
produced while \pitrv contributed about 7\%. Similarly, the blue shaded
box-plot represents the relative frequency of particular mutation operator
in the total mutants \textit{detected}. For example, \pitnvmc contribution
in the detected mutants was 23\% while that of \pitrv was 15\%.

For a detailed description of each mutants, please see~\cite{pitmut}.
PIT was also modifed to provide random selection of mutants according
to various criterias. Finally, to remove random noice, each criteria
described has been run four times, and the results are averaged to produce
the final result.

\begin{table}
\small{
\begin{tabular}{ll}
\hline \hline \\
\pitin & Remove negative sign from numbers\\
\pitrv & Mutate return values\\
\pitm & Mutate arithmetic operators\\
\pitvmc & Remove void method calls\\
\pitnc & Negate conditional statements\\
\pitcb & Modify boundaries in logical conditions\\
\piti & Modify increment and decrement statements\\
\pitnvmc & Remove non-void method calls, returning default value \\
\pitcc & Replace constructor calls, returning null \\
\pitic & Replace inline constants with default value \\
\pitri & Remove increment and decrement statements \\
\pitemv & Replace member variable assignments with default value \\
\pites & Modify switch statements \\
\pitrs & Replace switch labels with default (thus removing them) \\
\pitrc & Replace boolean conditions with true\\
\pitnc & Replace boolean conditions with false\\
\hline
\end{tabular}
}
\caption{PIT Mutation Opeators (We have used abbreviations instead of operator names.)}
\label{tbl:pitop}
\end{table}


One of the criterias we sampled was \textit{statement deletion}.
Since we use PIT, which is a bytecode based mutation engine, implementing direct equivalent of
source code statement deletion is very hard. We were able to approximate statement deletion
by combining different bytecode operators, which is explained in Subsection~\ref{subsec:stmtdel}.

\subsection{Sampling Criterias}

We used several different sampling criteria, some of which has been suggested
in the literature before, and some which are variants of previously suggested
criteria, and some that have not been used before.  For each sampling
criteria, we sampled mutants on a decreasing power scale sampling
\textit{1, 1/2, 1/4, 1/8, 1/16, 1/64} of the total mutants.

\subsubsection{x\% selection}
The simplest one consisted of using x\% selection as suggested by
Budd~\cite{budd1980mutation}. In this criteria, we choose a specific
fraction of the complete set of mutants. This criteria also serves as a
control for the verifying the effectiveness of other criteria.

\subsubsection{x\% selection over program elements}
Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we
extended x\% selection to sample from within different program elements.
We sampled in the increasing order of scope, --- \textit{line},
\textit{method} and \textit{class} (\textit{project} scope was
analyzed as part of x\% selection).

While the criteria is simple, it is not immediately clear when we
are faced with program elements that produced too few mutants for a particular
fraction to yield at-least one mutant. For example, for a line that produced
15 mutants, the number of mutants that can be chosen in \textit{(x\%, line,
1/64)} is less than 1. We analyzed the results of the following criterias:
1) to apply \textit{round} function to the resulting number and covert to
the nearest integer, and choose that value as the number of mutants (in
effect, ignoring elements that are less complex), 2) to apply \textit{ceil}
function to the resulting value, ensuring that there is atleast one mutant
per program element, and 3) to apply \textit{sample} criteria suggested by
Zhang et al.~\cite{zhang2013ase}, which chooses a mutant with given fracton
as probability.
% TODO: If the criterias ceil and round does not make sense, we might remove them to gain space.

\subsubsection{Lines per element}
Our previous research~\cite{gopinath2014code} found that statement coverage was highly correlated with mutation coverage for a project. This immediately suggests that perhaps choosing one mutant per line may be sufficient to achieve a close approximation of the final mutation score. Further, statement deletion has been researched previously~\cite{untch2009onreduced,deng2013empirical} and has been found to reduce the number of mutants well, without an appreciable decrease in accuracy. This also provides a nice comparison with similar number of mutants between operator selection and random sampling of mutants.

A simple extension of this approach is to extend this strategy as previously, by choosing as many number of mutants as there are number of lines in a program element, and we can extend it as before to sample \textit{1/2,1/4,1/8,1/16,1/32,1/64} of the mutants thus chosen. We chose the rounding strategy for fractional samples for simplicity.
% TODO: Actually do the other rounding choices.

Here too, we have a few choices when sampling mutants. We could either choose the fraction of mutants within the program element, or we could apply the sampling externally. For example, using $\lambda_E$ as number of lines in an element, for \textit{(lpe, $1/2$, method)}, we first get $1/2 \times \lambda_{Method}$ number of mutants from each method. The second alternative is to get $\lambda_{Method}$ number of mutants for all methods, then from this larger set, choose only half of the mutants.

\subsubsection{One per element}
An extremely simple strategy of sampling is to just choose one mutant per program element, which as before, we extended to include all the fractions \textit{1/2,1/4,1/8,1/16,1/32,1/64}.

\subsection{Operator Selection}
% TODO expand as required

For selective methods, we tried mutation operators suggested by Wong et al.~\cite{wong1995reducing}, Offutt et al.~\cite{offutt1996anexperimental,deng2013empirical}, % TODO Barbosa
 and, Namin et al~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized operator selection mechanisms, we also compared the Javalanche operators for operator selection. Note that all of these techniques except 
Javalanche have targeted C programs, thus some of these operators
are sensible in C but in Java programs. For example C compilers tolerate
removing a return statement but, in Java, it causes a compilation error.
Moreover, there were some operators that are not supported by PIT framework
like ABS (absolute mutation operators), however, we tried to realize as many
as possible operators using PIT's bytecode level mutation. We also extended 
the PIT framework to support the  statement deletion operator (SDL).


{\bf Amin: The rest of this section is for Alex and Carlos info and should be verified if we should include this or wave our hands about approximation instead.}

\subsubsection{Criteria I}
For this criteria, we used the two operators \pitcb, and \pitnc which are similar to those given by Wong. We did not have ABS operator available in PIT.
\subsubsection{Criteria II}
We used the operators given by Offutt et al. \pitin, \pitm, \pitcb, \pitnc. We did not have LCR available in PIT.
\subsubsection{Criteria III}
Those given by Javalanche \pitnc, \pitvmc, \pitnvmc, \pitm, \pitic, \pitemv. 
\subsubsection{Criteria IV}
By Namin et al. \pitin, \pitm, \piti, \pitnc. Many of operators were not applicable in Java and some were not available in PIT like IndVarBitNeg.

\subsubsection{Statement Deletion:}
\label{subsec:stmtdel}
The basic statement deletion was modeled on the work by Deng et
al.~\cite{deng2013empirical}. The operations on single statements was modeled
using \pitvmc, \pitnvmc, \pitcc, \pitemv, \pitri
for simple statements, and using \pitrc for control structures,
which replaced the boolean condition with false, resulting in removal of
the block of statements. The operator for return values was modeled using
\pitrv, which is similar.  The operators for \textit{while,for},
and \textit{if} statements were modeled using \pitdc,
which replaced the boolean condition with true, which removed the effect
of conditional. The \textit{switch} statement deletion was modeled using
\pitrs which replaced the first 100 labels with default label,
resulting in the switch element getting deleted. (Due to the constraints
of the architecture of PIT only the first 100 labels were replaced). The
\textit{try catch} was not necessary at bytecode level.  Finally, to get an
accurate estimation of the effect of true statement deletion, we grouped
the mutants by line, and considered a single virtual mutant (That is, the
total number of mutants is equal to the total number of lines). Further,
killing any mutant from a line resulted in marking the virtual mutant
for that line as killed. This gave us the mutation score for the virtual
statement deletion operator.  We note that the approximation of simple
statement deletion, especially when arithmetic operators are involved is not
complete. However, as seen in Figure~\ref{fig:op}, the number of mutants
produced by \pitm operator is very small. We also note that our
approximation does not account for the increase in ease of detection when
multiple mutations are combined together due to coupling effect. This also
means that not all the lines may be mutated since there may be no applicable
operators. However, given the constraints of a bytecode based mutation system,
we believe that our procedure is reasonable.

