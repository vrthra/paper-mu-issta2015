<<tblsubsumption, child='tbl.subsumption.Rnw'>>=
@
<<tblpitmut, child='tbl.pitmut.Rnw'>>=
@
<<figsubsumption, child='fig.subsumption.Rnw'>>=
@

\section{Methodology}
\label{sec:methodology}
Our selection of programs was driven by a few overriding concerns. Our
primary requirement was that our results had to be as widely applicable as
possible for real-world programs. Secondly, we strived for a statistically
significant result, reducing the number of variables present in the
experiments. For this reason we chose a random sample of Java projects from
Github~\cite{github} and Apache Software Foundation~\cite{apache} that use
the popular maven~\cite{maven} build system, following the methodology we
used previously in an ICSE 2014 paper~\cite{gopinath2014code}.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are limited,
we extended PIT to provide newer operators that are similar to operators
provided by other mutation systems. The set of operators that we used is
provided in Table~\ref{tbl:pitop}.

In order to ensure that the operators that we added were not redundant,
we computed their operator subsumption matrix. This is given in
Table~\ref{tbl:subsumption}. In the table, the mean number of mutants
of an operator in the row subsumed by another operator in the column
is given as the decimal fraction (i.e $1.0$ suggests complete subsumption
of one mutation operator by the other). A visualization of the subsumption is
presented in Figure~\ref{fig:subsumption}. In the figure, the amount of
subsumption is indicated by removal of area from the circle, with same
operators subsuming themselves entirely. This suggests that the operators
we used were non-redundant, with a maximum subsumption of only $40\%$.
The Figure~\ref{fig:mutationshare} shows the share of each mutation operators
in the total number of mutants produced, and the Figure~\ref{fig:mutationkills}
shows the relative frequency with which tests are able to cover and kill
different mutation operators.

For a detailed description of each mutation operator, please refer to PIT
documentation~\cite{pitmut}.  We modified PIT to report the entire test
matrix of $tests \times failures$ rather than just the first failure, and
used this for our analysis. To remove the effects of random noise, results
of each criteria was averaged out of ten runs.

\subsection{Sampling Criteria}
We used several different sampling criteria that has been mentioned in the
literature, For each sampling criteria, we sampled mutants on a decreasing
power scale, sampling $\frac{1}{2}$, $\frac{1}{4}$, $\frac{1}{8}$,
$\frac{1}{16}$, $\frac{1}{32}$, $\frac{1}{64}$ of the total mutants.

\subsubsection{Uniform random sampling}
The simplest sampling approach consisted of using x\% selection as suggested
by Budd~\cite{budd1980mutation}. In this criteria, we choose a specific
fraction of the complete set of mutants. This criteria also serves as a
baseline for verifying the effectiveness of other criteria.

\subsubsection{Stratified random sampling over mutation operators}
This strategy, first suggested by Wong et al.~\cite{wong1995reducing}
samples an equal percentage of mutants from each operator. While Wong seems
to treat this as same as x\% selection, without giving any further
justification as to why it was used instead, we note that this sampling is
subtly different from pure random sampling in that it provides a stratified
sampling based on mutation operators.

\subsubsection{Stratified random sampling over program elements}
Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we extended
x\% selection criteria to sample from within different program elements.
We sampled in increasing order of scope, --- \textit{line}, \textit{method}
and \textit{class} (\textit{project} scope is just x\% selection).

We used the formula by Zhang et al.~\cite{zhang2013ase},
\[sample(x) = \lfloor x + random(0..1) \rfloor \]
to correctly sample decimal numbers.

\subsection{Operator Selection}
For selective methods, we tried mutation operators
suggested by Wong et al.~\cite{wong1995reducing}, Offutt et
al.~\cite{offutt1996anexperimental,deng2013empirical}, and, Namin et
al.~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized
operator selection mechanisms, we also compared the Javalanche operators for
operator selection. Note that all of these techniques except Javalanche have
targeted C programs. Thus, some of these operators may be sensible in C but
not in Java. For example, deletion of return statement is tolerated in C,
not in Java.  Moreover, there were a few operators that were not supported
by the PIT, and could not be implemented easily (as mentioned below).

\subsubsection{Constrained Mutation}
\noindent\textbf{Wong et al. ~\cite{wong1995reducing}.} They selected ROR
and ABS from Mothra for mutation analysis. We used operators \Pitcb and
\Pitnc to model ROR operator. There are no comparable operators to ABS in PIT.

\subsubsection{E-Selective}
\noindent\textbf{Offut et al. \cite{offutt1996anexperimental}.} They selected
ABS, UOI, LCR, AOR, ROR from Mothra operators.  We have used  \Pitin, \Pitm,
\Pitcb, and \Pitnc. PIT does not have any operator comparable to LCR.

\subsubsection{Javalanche}
\noindent\textbf{Javalanche \cite{javalanche}.}
Javalanche uses Negate Jump Condition, Omit Method Call, Replace Arithmetic
Operator, and Replace Numerical Constant operators. We have used \Pitnc,
\Pitvmc, \Pitnvmc, \Pitm, \Pitic and \Pitemv to model them.

\subsubsection{Variable Reduction}
\noindent\textbf{Namin et al.~\cite{siami2008sufficient}.}
They have tried to reduce the mutation operators of Proteum analysis
tool which is for C programs. They suggest 28 operators which many of them
are not applicable in Java, and some not in PIT.
We  used by  \Pitin, \Pitm, \Piti, and \Pitnc.

\subsubsection{N-selection}
\noindent\textbf{Offut et al. ~\cite{offutt1993experimental}.} They suggested removal of
$n$ most numerous operators. In our experiment, the order of operators was
\Pitnvmc, \Pitrv, \Pitic, \Pitdc, \Pitnc, \Pitrc, \Pitvmc, \Pitcc, \Pitemv,
\Pitm, \Pitcb, \Piti, \Pitri, \Pitrs, \Pites, and \Pitin.
We discarded one at each
step and evaluated the effectiveness at each $n$.
%----------------------------------------
\subsubsection{Statement deletion emulation} \label{subsec:stmtdel}

The statement deletion based operator selection was based on the work by
Deng et al.~\cite{deng2013empirical}. The operations on single
statements were modeled using \Pitvmc, \Pitnvmc, \Pitcc, \Pitemv, and
\Pitri~for simple statements, and using \Pitrc for control structures. \Pitrc
replaces boolean conditions with \textit{false}, resulting in removal of the
conditional block. The operator for return values was modeled using
\Pitrv, which is similar.  The operators for \textit{while},
\textit{for}, and \textit{if} statements were modeled using \Pitdc,
which replaced the boolean condition with \textit{true}, which removed the
effect of conditional. The \textit{switch} statement deletion was
modeled using \Pitrs which replaced the first 100 labels with a
\textit{default} label, resulting in the switch element being
deleted. Due to the constraints of the architecture of PIT only the
first 100 labels were replaced. Deleting \textit{try/catch} was not
necessary at bytecode level.

Note that we are not attempting to evaluate statement deletion mutation
directly here. Rather, we have chosen a set of operators that could be
involved in deletion of statements, and have used that as an operator
selection criteria. This means that in order to translate the results
from our experiment back to original statement deletion operator, we need
to rely on some assumptions. They are, 1) Coupling effect: If a test is
able to kill a mutant in this set, then it should kill it even when it
is in combination with other mutants of this set (resulting in deletion
of deletion of the statement in question). Note that there is a
possibility for statement deletion to be less effective than our
experiment, that is, for actual deleted statements to be detected more
often than individual mutants are detected. However, this does not adversely
affect our final conclusions.

Finally, while the utility measures and the effectiveness for deletion based
operators should hold when translating to true statement deletion, the mutation
share reported is based on the independent mutants, and should not be taken
as the mutation share of true statement deletion.

% Finally, to get an accurate estimation
% of the effect of true statement deletion, we grouped the mutants by
% line, and considered each line a single virtual mutant (that is, the total
% number of mutants is equal to the total number of lines). Further,
% killing any mutant from a line resulted in marking the virtual mutant
% for that line as killed. This gave us the mutation score for the
% virtual statement deletion operator.  We note that the approximation
% of simple statement deletion, especially when arithmetic operators are
% involved, is not complete. However,
% the number of mutants produced by \Pitm operator is very small. We
% also note that our approximation does not account for the increase in
% ease of detection when multiple mutations are combined together due to
% the coupling effect. This also means that not all the lines may be
% mutated ,since there may be no applicable operators. However, given
% the constraints of a bytecode based mutation system, we believe that
% our procedure is reasonable.
% An interesting point is that using this


%procedure statement, deletion is no longer a simple mutation and
%qualifies as a higher order mutation operator. In fact, the procedure
%we outlined can be used in general to judge the effectiveness of a
%higher order operator from the results of the first order mutation
%operators that together compose the higher order mutant.

