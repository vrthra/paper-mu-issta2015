\section{Methodology}
\label{sec:methodology}
Our selection of programs was driven by a few overriding concerns. Our primary
requirement was that, our results had to be as widely applicable as possible
for real-world programs. Secondly, we strived for a statistically significant
result, reducing the amount of variables present in the experiments. For this
reason we chose a random sample of Java projects from Github\cite{github}
that uses the popular maven\cite{maven} build system, that has been used
elsewhere\cite{gopinath2014code}. This set of projects comes in two flavors
of test-suites. The original test-suites present in a limited number of
projects, and automatically generatd test-suites using randoop.  Due to the
constraints in resources, we had to further reduce the programs and test-suites
to those that could finish the mutation run in 10 minutes. From this set
of test-suites, we sampled 110 suites each for both original and randoop
generated test-suiets. This gave us 81 unique projects for both original
and randoop, and remaining projects having both flavors of test suites.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are limited,
we extended PIT to provide newer operators that are similar to operators
provided by other mutation systems. The set of operators provided by PIT
are provided in Table~\ref{tbl:pitop}.

Further, we also modified PIT to provide random selection of mutants according
to various criterias.

\begin{table}[h]\footnotesize
\begin{tabular}{ll}
\pitic & Invert negatives \\
\pitrv & Change return values \\
\pitm & Modify arithmetic operators\\
\pitvmc & Remove void method calls \\
\pitnc & Negate conditional statements \\
\pitcb & Modify boundary conditions \\
\piti & Modify increment/decrement \\
\pitnvmc & Replace non-void method calls \\
\pitcc & Replace constructor calls \\
\pitic & Replace inline constants \\
\piti & Remove increment/decrement \\
\pitemv & Replace member variable assignments \\
\pites & Modify switch statements \\
\pitrs & Remove switch elements* \\
\pitrc & Make conditionals true \\
\pitnc & Make conditionas false* \\
\hline
\end{tabular}
\caption{PIT Mutation Opeators}
\label{tbl:pitop}
\end{table}

Finally, to ensure accuracy of our observations, each criteria described has been run four times, and the results are averaged to produce the final result.

One of our research questions was to compare the utility of operator
selection --- especially statement deletion --- with random sampling of mutants,
Since we use PIT, which is a bytecode oriented mutation engine, implementing statement deletion
directly is very hard. However, we can approximate statement deletion by combining different
bytecode operators, as explained later.

\subsection{Sampling Criterias}

We used several different sampling criterias.

\subsubsection{x\% selection}
The simplest one consisted of using x\% selection as suggested by Wong et al.~\cite{wong1995reducing}. In this criteria, we choose a specific fraction of the complete mutants. Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we extend this criteria to sample mutants from within different program elements. We sampled x\% selection in the increasing order of scope, --- \textit{line}, \textit{method}, \textit{class}, and \textit{project} --- and decreasing fraction of total mutants -- \textit{1, 1/2, 1/4, 1/8, 1/16, 1/64}.

While the sampling criteria is simple, it is not immediately clear when we are faced with program elements that produced too few mutants for a particular fraction to yield at-least one mutant. For example, for a line that produced 15 mutants, the number of mutants that can be chosen in \textit{(x\%, line, 1/64)} is less than 1. We analyzed the results of the following criterias: 1) to apply \textit{round} function to the resulting number and covert to the nearest integer, and choose that value as the number of mutants (in effect, ignoring elements that are less complex), 2) to apply \textit{ceil} function to the resulting value, ensuring that there is atleast one mutant per program element, and 3) to apply \textit{sample} criteria suggested by Zhang et al.~\cite{zhang2013ase}, which chooses a mutant with given fracton as probability.
% TODO: If the criterias ceil and round does not make sense, we might remove them to gain space.

\subsubsection{Lines per element}
Our previous research~\cite{gopinath2014code} found that statement coverage was highly correlated with mutation coverage for a project. This immediately suggests that perhaps choosing one mutant per line may be sufficient to achieve a close approximation of the final mutation score. Further, statement deletion has been researched previously~\cite{untch2009onreduced,deng2013empirical} and has been found to reduce the number of mutants well, without an appreciable decrease in accuracy. This also provides a nice comparison with similar number of mutants between operator selection and random sampling of mutants.

A simple extension of this approach is to extend this strategy as previously, by choosing as many number of mutants as there are number of lines in a program element, and we can extend it as before to sample \textit{1/2,1/4,1/8,1/16,1/32,1/64} of the mutants thus chosen. We chose the rounding strategy for fractional samples for simplicity.
% TODO: Actually do the other rounding choices.

Here too, we have a few choices when sampling mutants. We could either choose the fraction of mutants within the program element, or we could apply the sampling externally. For example, using $\lambda_E$ as number of lines in an element, for \textit{(lpe, $1/2$, method)}, we first get $1/2 \times \lambda_{Method}$ number of mutants from each method. The second alternative is to get $\lambda_{Method}$ number of mutants for all methods, then from this larger set, choose only half of the mutants.

\subsubsection{One per element}
An extremely simple strategy of sampling is to just choose one mutant per program element, which as before, we extended to include all the fractions \textit{1/2,1/4,1/8,1/16,1/32,1/64}.

\subsection{Operator Selection}
% TODO expand as required

For selective methods, we tried mutation operators suggested by Wong et al.~\cite{wong1995reducing}, Offutt et al.~\cite{offutt1996anexperimental,deng2013empirical}, % TODO Barbosa
 and, Namin et al~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized operator selection mechanisms, we also compared the Javalanche operators for operator selection. Note that all of these techniques except 
Javalanche have targeted C programs, thus some of these operators
are sensible in C but in Java programs. For example C compilers tolerate
removing a return statement but, in Java, it causes a compilation error.
Moreover, there were some operators that are not supported by PIT framework
like ABS (absolute mutation operators), however, we tried to realize as many
as possible operators using PIT's bytecode level mutation. We also extended 
the PIT framework to support the  statement deletion operator (SDL).


{\bf Amin: The rest of this section is for Alex and Carlos info and should be verified if we should include this or wave our hands about approximation instead.}

\subsubsection{Criteria I}
For this criteria, we used the two operators \pitcb, and \pitnc which are similar to those given by Wong. We did not have ABS operator available in PIT.
\subsubsection{Criteria II}
We used the operators given by Offutt et al. \pitin, \pitm, \pitcb, \pitnc. We did not have LCR available in PIT.
\subsubsection{Criteria III}
Those given by Javalanche \pitnc, \pitvmc, \pitnvmc, \pitm, \pitic, \pitemv. 
\subsubsection{Criteria IV}
By Namin et al. \pitin, \pitm, \piti, \pitnc. Many of operators were not applicable in Java and some were not available in PIT like IndVarBitNeg.

\subsubsection{Statement Deletion:}
The basic statement deletion was modeled on the work by Deng et
al.~\cite{deng2013empirical}. The operations on single statements was modeled
using \pitvmc, \pitnvmc, \pitcc, \pitemv, \pitri
for simple statements, and using \pitrc for control structures,
which replaced the boolean condition with false, resulting in removal of
the block of statements. The operator for return values was modeled using
\pitrv, which is similar.  The operators for \textit{while,for},
and \textit{if} statements were modeled using \pitdc,
which replaced the boolean condition with true, which removed the effect
of conditional. The \textit{switch} statement deletion was modeled using
\pitrs which replaced the first 100 labels with default label,
resulting in the switch element getting deleted. (Due to the constraints
of the architecture of PIT only the first 100 labels were replaced). The
\textit{try catch} was not necessary at bytecode level.  Finally, to get an
accurate estimation of the effect of true statement deletion, we grouped
the mutants by line, and considered a single virtual mutant (That is, the
total number of mutants is equal to the total number of lines). Further,
killing any mutant from a line resulted in marking the virtual mutant
for that line as killed. This gave us the mutation score for the virtual
statement deletion operator.  We note that the approximation of simple
statement deletion, especially when arithmetic operators are involved is not
complete. However, as seen in Figure~\ref{fig:op}, the number of mutants
produced by \pitm operator is very small. We also note that our
approximation does not account for the increase in ease of detection when
multiple mutations are combined together due to coupling effect. This also
means that not all the lines may be mutated since there may be no applicable
operators. However, given the constraints of a bytecode based mutation system,
we believe that our procedure is reasonable.


\subsection{Mutant Clustering}
For mutant clustering, we were unable to directly apply clustering based on distinct mutants as suggested by Hussain~\cite{hussain2008mutation}. However, we were able to apply clustering techniques on mutation operators, thus turning it to a set of selected operators.
