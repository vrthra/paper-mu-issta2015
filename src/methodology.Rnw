\section{Methodology} \label{sec:methodology} Our selection of
programs was driven by a few overriding concerns. Our primary
requirement was that our results had to be as widely applicable as
possible for real-world programs. Secondly, we strived for a
statistically significant result, reducing the number of variables
present in the experiments. For this reason we chose a random sample
of Java projects from Github~\cite{github} that use the popular
maven~\cite{maven} build system, following the methodology we used
previously in an ICSE 2014 paper~\cite{gopinath2014code}. As in that
work, we utilize two kinds of of test suites: the original test suites
present in a limited number of projects, and automatically generated
test suites from Randoop~\cite{randoop}. From this set of test suites,
After eliminating those that took too long to finish, we sampled 107
suites each for both original and Randoop generated test suites,
Since there was some overlap between projects with
original test suites, and those with generated test suites, we had 81
unique projects each in both sets. The remaining 26 projects had both
flavors of test suites.

We ran mutation analysis on this set of projects using
PIT\cite{pitest}. However, since the operators provided by PIT are
limited, we extended PIT to provide newer operators that are similar to
operators provided by other mutation systems. The set of operators that
we used is provided in Table~\ref{tbl:pitop}.
% Figure~\ref{fig:op} shows
% the distribution of mutants and the relative detection rates of each
% mutation operator for our projects. In the figure, there are two box-plots
% corresponding to each mutation operator on the Y-axis. The black box represents
% the relative frequency of the particular mutation operator in the total
% mutants \textit{produced}. For example, for projects in the (Randoop) generated set,
% the operator \pitnvmc contributed about 34\% of the total number of mutants
% produced while \pitrv contributed about 7\%. Similarly, the blue shaded
% box-plot represents the relative frequency of particular mutation operator
% in the total mutants \textit{detected}. For example, \pitnvmc contribution
% in the detected mutants was 23\% while that of \pitrv was 15\%.

For a detailed description of each mutation operator, please refer to PIT documentation~\cite{pitmut}.
PIT was also modified to provide random selection of mutants according
to various criteria.
Finally, to remove random noise, each criteria
described was run four times, and the results averaged to produce
the final result.

\begin{table}
\small{
\begin{tabular}{ll}
\hline \hline \\
\pitin & Remove negative sign from numbers\\
\pitrv & Mutate return values\\
\pitm & Mutate arithmetic operators\\
\pitvmc & Remove void method calls\\
\pitnc & Negate conditional statements\\
\pitcb & Modify boundaries in logical conditions\\
\piti & Modify increment and decrement statements\\
\pitnvmc & Remove non-void method calls, returning default value \\
\pitcc & Replace constructor calls, returning null \\
\pitic & Replace inline constants with default value \\
\pitri & Remove increment and decrement statements \\
\pitemv & Replace member variable assignments with default value \\
\pites & Modify switch statements \\
\pitrs & Replace switch labels with default (thus removing them) \\
\pitrc & Replace boolean conditions with true\\
\pitnc & Replace boolean conditions with false\\
\hline
\end{tabular}
}
\caption{PIT Mutation Operators (We have used abbreviations instead of operator names.)}
\label{tbl:pitop}
\end{table}

\subsection{Sampling Criteria}

We used several different sampling criteria, some of which has been suggested
in the literature before, some which are variants of previously suggested
criteria, and a few novel ones.  For each sampling
criteria, we sampled mutants on a decreasing power scale, sampling
\textit{1/2, 1/4, 1/8, 1/16, 1/32, 1/64} of the total mutants.

\subsubsection{x\% selection}
The simplest sampling approach consisted of using x\% selection as suggested by
Budd~\cite{budd1980mutation}. In this criteria, we choose a specific
fraction of the complete set of mutants. This criteria also serves as a
baseline for verifying the effectiveness of other criteria.

\subsubsection{Sampling over program elements and variants}
Following the suggestion of Zhang et al.~\cite{zhang2013ase}, we
extended x\% selection criteria to sample from within different program
elements.  We sampled in increasing order of scope,
--- \textit{line}, \textit{method} and \textit{class} (\textit{project}
scope is just x\% selection).

We used the formula by Zhang et al.~\cite{zhang2013ase},
\[sample(x) = \lfloor x + random(0..1) \rfloor \]
to correctly sample decimal numbers.
Next, we slightly modified this criteria, and instead of
\textit{sample()} which uses probability to manage the decimal numbers,
we applied \textit{round()} to obtain the nearest whole number, which
was used as the number of samples to be chosen from the population.
The new strategy ignores program elements with small number of mutants.
This strategy can potentially guide mutation generation toward more
complex program elements.
That is, if the number of mutants dropped below a threshold determined by
the mutant reduction ratio, that program element would not contribute any
mutants to the final result.  Conceptually the idea is that mutants of more
complex code have more discriminatory power (and may correspond better to
real faults --- though we do not evaluate this concept).

Next, we explored in the other direction, by forcing the program elements
to return at least one element by using \textit{ceil()}. That is,
irrespective of the fraction being sampled, the simplest elements always
contributed at least one mutant to the total sample, ensuring coverage but
also giving priority to complex elements.

\subsubsection{Lines per element and variants}
Our previous research~\cite{gopinath2014code} found that statement coverage
was highly correlated with mutation score for a project. This immediately
suggests that perhaps choosing one mutant per line may be sufficient to achieve
a close approximation of the final mutation score. Further, statement deletion
has been researched previously~\cite{untch2009onreduced,deng2013empirical} and
has been found to reduce the number of mutants well, with negligible
decrease in effectiveness. This also provides a nice comparison with similar
numbers of mutants between operator selection and random sampling of mutants.

We extended sampling to levels coarser than methods, i.e. method, class, and
project. We sampled $n$ mutants from a method (class or project), where $n$
is the number of statements in the method (class or project).

This provided a test of the hypothesis of how important a mutation sampling's
relationship to simple code coverage is. This was extended to class and
project scope also.

For the first variant, we applied the x\% sampling to the result of
the first sampling based on line counts. That is, in the case of
methods, we first selected \textit{linecount} mutants each from each
method, and applied the x\% selection to this result.
For example, for $1/2$ sampling on methods if one method had
$10$ lines and another had $20$, we sampled $10$ mutants from
the first, and $20$ from the second, and from the combined
$30$ mutants, we sampled $15$.  For the second variant, we did the
sampling in one go, where we chose \textit{linecount/x} number of
mutants from each program element.  That is, in the previous example,
only $5$ mutants from the first and $10$ mutants from the second
method would be chosen.

\subsubsection{One per element}
Another simple strategy of sampling we experimented with is to just choose
one mutant per program element, in the order \textit{line}, \textit{method}, \textit{class}.

\subsubsection{x\% selection per operator}
This strategy, first suggested by Wong et al.~\cite{wong1995reducing} samples an equal percentage
of mutants from each operator.

\subsection{Operator Selection}
For selective methods, we tried mutation operators
suggested by Wong et al.~\cite{wong1995reducing}, Offutt et
al.~\cite{offutt1996anexperimental,deng2013empirical}, and, Namin et
al.~\cite{siami2008sufficient}. Since Javalanche~\cite{javalanche} utilized
operator selection mechanisms, we also compared the Javalanche operators for
operator selection. Note that all of these techniques except Javalanche have
targeted C programs. Thus, some of these operators may be sensible in C but not
in Java. For example, deletion of return statement is tolerated in C,
not in Java.  Moreover, there were a few operators that were not supported
by the PIT, and could not be implemented easily (as mentioned below).

\subsubsection{Constrained Mutation}
\noindent\textbf{Wong et al. ~\cite{wong1995reducing}.}
They selected ROR  and ABS  from Mothra for
mutation analysis. We used operators
\pitcb and \pitnc to model ROR operator. There are no comparable operators to ABS in PIT.

\subsubsection{E-Selective}
\noindent\textbf{Offut et al. \cite{offutt1996anexperimental}.}
They selected ABS, UOI, LCR, AOR, ROR from Mothra operators.
We have used  \Pitin, \Pitm, \Pitcb, and \Pitnc. PIT does not have any operator
comparable to LCR.

\subsubsection{Javalanche}
\noindent\textbf{Javalanche \cite{javalanche}.}
Javalanche uses Negate Jump Condition, Omit Method
 Call, Replace Arithmetic Operator, and Replace Numerical
 Constant operators. We have used \Pitnc, \Pitvmc,
\Pitnvmc, \Pitm, \Pitic and \Pitemv to model them.

\subsubsection{Variable Reduction}
\noindent\textbf{Namin et al.~\cite{siami2008sufficient}.}
They have tried to reduce the mutation operators of Proteum analysis
tool which is for C programs. They suggest 28 operators which many of them
are not applicable in Java, and some not in PIT.
We  used by  \Pitin, \Pitm, \Piti and \Pitnc.

\subsubsection{N-selection}
\noindent\textbf{Offut et al. ~\cite{offutt1993experimental}.} They suggested removal of
$n$ most numerous operators. In our experiment, the order of operators was
\Pitnvmc, \Pitrv, \Pitic, \Pitdc, \Pitnc, \Pitrc, \Pitvmc, \Pitcc, \Pitemv,
\Pitm, \Pitcb, \Piti, \Pitri, \Pitrs, \Pites, and \Pitin
We discarded one at each
step and evaluated the effectiveness at each $n$.
%----------------------------------------
\subsubsection{Statement Deletion} \label{subsec:stmtdel} The basic
statement deletion was modeled on the work by Deng et
al.~\cite{deng2013empirical}. The operations on single statements were
modeled using \Pitvmc, \Pitnvmc, \Pitcc, \Pitemv, and \Pitri~for
simple statements, and using \pitrc for control structures. \pitrc
replaces boolean conditions with \textit{false}, resulting in removal of the
conditional block. The operator for return values was modeled using
\Pitrv, which is similar.  The operators for \textit{while},
\textit{for}, and \textit{if} statements were modeled using \Pitdc,
which replaced the boolean condition with \textit{true}, which removed the
effect of conditional. The \textit{switch} statement deletion was
modeled using \pitrs which replaced the first 100 labels with a
\textit{default} label, resulting in the switch element being
deleted. Due to the constraints of the architecture of PIT only the
first 100 labels were replaced. Deleting \textit{try/catch} was not
necessary at bytecode level.  Finally, to get an accurate estimation
of the effect of true statement deletion, we grouped the mutants by
line, and considered each line a single virtual mutant (that is, the total
number of mutants is equal to the total number of lines). Further,
killing any mutant from a line resulted in marking the virtual mutant
for that line as killed. This gave us the mutation score for the
virtual statement deletion operator.  We note that the approximation
of simple statement deletion, especially when arithmetic operators are
involved, is not complete. However,
the number of mutants produced by \pitm operator is very small. We
also note that our approximation does not account for the increase in
ease of detection when multiple mutations are combined together due to
the coupling effect. This also means that not all the lines may be
mutated ,since there may be no applicable operators. However, given
the constraints of a bytecode based mutation system, we believe that
our procedure is reasonable.
% An interesting point is that using this
%procedure statement, deletion is no longer a simple mutation and
%qualifies as a higher order mutation operator. In fact, the procedure
%we outlined can be used in general to judge the effectiveness of a
%higher order operator from the results of the first order mutation
%operators that together compose the higher order mutant.

