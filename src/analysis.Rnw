\section{Analysis}
\label{sec:analysis}
\begin{figure*}[!htb]
<<op,fig.width=10, fig.height=5, out.width='.95\\linewidth', out.heigth='4in', echo=F, message=F, warn=F,fig.lp="fig:">>=
par(las=1,mfrow = c(1, 2),mar=c(2,8,1,1))
o.all <- cbind(projects = rownames(o.dist.all), stack(o.dist.all))
o.all$ind <- clean(o.all$ind)
bcol <- '#2171B5'
#bcol <- 'darkgray'
icol <- '#9ECAE0'
#icol <- 'lightgray'
o.det <- cbind(projects = rownames(o.dist.det), stack(o.dist.det))
o.det$ind <- clean(o.det$ind)
with(o.det,boxplot(values~ind,horizontal=T,border=c(bcol), col=icol, pch='.', axes=F, ylim=c(0,0.6)))
with(o.all,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Original', cex.axis=0.8, ylim=c(0,0.6),add=T))

r.all <- cbind(projects = rownames(r.dist.all), stack(r.dist.all))
r.all$ind <- clean(r.all$ind)
r.det <- cbind(projects = rownames(r.dist.det), stack(r.dist.det))
r.det$ind <- clean(r.det$ind)
with(r.det,boxplot(values~ind,horizontal=T,border=c(bcol), col=icol, pch='.', axes=F,ylim=c(0,0.6)))
with(r.all,boxplot(values~ind,horizontal=T,border=c('black'), pch='.',main='Randoop', cex.axis=0.8,ylim=c(0,0.6),add=T))
@
\caption{The relative contribution of mutation operators in terms of fraction of mutants generated and detected. \\
The blue shade represent detected mutants, while black represents total mutants.}
\label{fig:op}
\end{figure*}

First, we ran the the mutation analysis to identify the general distribution of mutants within our set of projects.
This provided us with the relative number of each mutation operators, that are produced, and also the general number of
mutants generated by each operator that was detected. This is given in Figure~\ref{fig:op}. This suggests that the operators
are distributed in the following order: \pitnvmc, \pitnc, \pitrc, \pitdc, \pitrv, \pitic, \pitcc, \pitemv, \pitvmc, \pitm,
\pitcb, \piti, \pitri, \pitrs, \pites, \pitin. We use this information later for n-selective mutation.

For comparing between different techniques, we ran correlation analysis between the full mutation score,
and that produced by the reduction criteria. Further, we also collected the mean reduction, and the standard
deviation of the reduction across all the projects for both randoop and original. These statistics are provided below.
\subsection{Sampling Criteria}
% We have power, element, kind(O/R), and MuRed, MuRedSD, R^2
\subsubsection{x\% selection}
<<xpercentunit>>=
sel.colnames <- c('operator', 'r.square', 'mutant.reduction', 'sd.reduction', 'sample', 'score.multiplier')
new.colnames <- c('operator', 'r^2',      'm.red',            'm.sd',         'num',    'B*')
stats.xp <- subset(stats.df, grepl('^(r|rr)[.]', operator)) # We are ignoring ceil here. add rc if needed.

o.stats.sel.xp <- subset(o.f(stats.xp), select=sel.colnames)
r.stats.sel.xp <- subset(r.f(stats.xp), select=sel.colnames)
stats.rest <- subset(stats.df, !grepl('^(r|rr|rc)[.]', operator))
colnames(o.stats.sel.xp) <- new.colnames
colnames(r.stats.sel.xp) <- new.colnames
@

\begin{table*}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(o.stats.sel.xp, caption='Original', label='table:rando'), include.rownames=FALSE, floating=FALSE, size='\\small')
@
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(r.stats.sel.xp, caption='Randoop', label='table:randr'), include.rownames=FALSE, floating=FALSE,size='\\small')
@
\end{minipage}
\bigskip
\caption {The x\% random selection criteria results.}
\label{tbl:xsel}
\end{table*}

\begin{figure*}[t]
<<x.per.sel.round,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='8in', echo=F, message=F, warn=F,fig.lp="fig:">>=
#myopts <- theme(panel.background = element_blank())
#myopts <-   theme_bw() +
#  opts(axis.line = theme_segment(colour = "black"),
#    panel.grid.major = theme_blank(),
#    panel.grid.minor = theme_blank(),
#    panel.border = theme_blank(),
#    panel.background = theme_blank()) 
  #theme with white background
myopts <- theme_bw() +
  #eliminates background, gridlines, and chart border
  theme(
    plot.background = element_blank()
   ,panel.grid.major = element_blank()
   ,panel.grid.minor = element_blank()
   ,panel.border = element_blank()
  ) + 
  #draws x and y axis line
  theme(axis.line = element_line(color = 'black'))
myopts <-  theme_classic() 
#+ opts(strip.background = theme_rect(colour = 'NA', fill = 'NA')) + opts(strip.text.y = theme_text(colour = 'white')) + theme(axis.line = element_line(color = 'black'))


o.xp <- subset(o.processed, grepl('^r[.].*.m[.]red',ind))
ggplot(subset(o.xp, values < 100), aes(power, values, fill=interaction(type,power), dodge=type)) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() + facet_wrap(~type)+ myopts
@
\caption{The effect of round(x) reduction, Except for line sampling of power $5$ and $6$ all others are above 0.90 $R^2$.}
\label{fig:xroundsel}
\end{figure*}

\begin{figure*}[t]
<<x.per.sel.sample,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='8in', echo=F, message=F, warn=F,fig.lp="fig:">>=
o.xp <- subset(o.processed, grepl('^rr[.].*.m[.]red',ind))
ggplot(subset(o.xp, values < 100), aes(power, values, fill=interaction(type,power), dodge=type)) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() + facet_wrap(~type) + myopts
@
\caption{The effect of sample(x) reduction. All are above 0.90 $R^2$.}
\label{fig:xsamplesel}
\end{figure*}
%TODO : See if the following paragraph is needed, or shall we just sink the ceil(x) discussion completely?
Our experiments found that while $round(x)$ and $sample(x)$ produced relatively reasonable reduction of mutants, the $ceil(x)$ criteria failed to produce a reasonable reduction of mutants except for higher power where the reduction was some what close to that produced by $round(x)$ and $sample(x)$ (which was expected). The $R^2$ values of $ceil(x)$ were almost always lower than that produced by $round(x)$ and $sample(x)$ for similar reduction of mutants. For this reason, we do not consider this function again. However, interested parties can refer to our published data.

The reduction in mutants for x\% selection using $round(x)$ is graphed in Figure~\ref{fig:xroundsel}. The values for the same are given in Table~\ref{tbl:xsel}.
Similarly reduction in mutants for x\% selection using $sample(x)$ is graphed in Figure~\ref{fig:xsamplesel}. The values for the same are given in Table~\ref{tbl:xsel}.
% ----------------------------------------------------------------------

\subsubsection{Lines per element}
The aim of this criteria is similar in some sense to selective mutation. While n-selective mutation ignores the most numerous mutant species, this criteria seeks to deprioritize the most complex program elements.

<<count>>=
stats.loc <- subset(stats.rest, grepl('^(l|wl)[.]', operator))
o.stats.sel.loc <- subset(o.f(stats.loc), select=sel.colnames)
r.stats.sel.loc <- subset(r.f(stats.loc), select=sel.colnames)
stats.rest <- subset(stats.rest, !grepl('^(l|wl)[.]', operator))
colnames(o.stats.sel.loc) <- new.colnames
colnames(r.stats.sel.loc) <- new.colnames
@
\begin{table*}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(o.stats.sel.loc, caption='Original', label='table:rando'), include.rownames=FALSE, floating=FALSE, size='\\small')
@
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(r.stats.sel.loc, caption='Randoop', label='table:randr'), include.rownames=FALSE, floating=FALSE,size='\\small')
@
\end{minipage}
\caption {The line count selection criteria results.}
\label{tbl:locsel}
\end{table*}

\begin{figure*}[t]
<<loc.per.sel.sample,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='8in', echo=F, message=F, warn=F,fig.lp="fig:">>=
o.loc <- subset(o.processed, grepl('^l[.].*.m[.]red',ind))
ggplot(subset(o.loc, values < 100), aes(power, values, fill=interaction(type,power), dodge=type)) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() + facet_wrap(~type) + myopts
@
\caption{The effect of loc (external) reduction. All are above 0.98 $R^2$.}
\label{fig:locsel}
\end{figure*}

\begin{figure*}[t]
<<wloc.per.sel.sample,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='8in', echo=F, message=F, warn=F,fig.lp="fig:">>=
o.loc <- subset(o.processed, grepl('^wl[.].*.m[.]red',ind))
ggplot(subset(o.loc, values < 100), aes(power, values, fill=interaction(type,power), dodge=type)) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() + facet_wrap(~type) + myopts
@
\caption{The effect of loc (internal) reduction. All are above 0.90 $R^2$.}
\label{fig:wlocsel}
\end{figure*}


The results of this selection criteria are provided in Table~\ref{tbl:locsel}. The effect of random selection within the program elements are visualized in Figure~\ref{fig:wlocsel}, and when it is made external to the program elements is visualized in Figure~\ref{fig:wlocsel}.

% ----------------------------------------------------------------------
\subsubsection{One per element}
The aim of this criteria is is to take the previous idea to the extreme. We choose only a single mutant per program element.

<<one>>=
stats.one <- subset(stats.rest, grepl('^o[.]', operator))

o.stats.sel.one <- subset(o.f(stats.one), select=sel.colnames)
r.stats.sel.one <- subset(r.f(stats.one), select=sel.colnames)
stats.rest <- subset(stats.rest, !grepl('^o[.]', operator))
colnames(o.stats.sel.one) <- new.colnames
colnames(r.stats.sel.one) <- new.colnames
@
\begin{table*}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(o.stats.sel.one, caption='Original', label='table:rando'), include.rownames=FALSE, floating=FALSE, size='\\small')
@
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(r.stats.sel.one, caption='Randoop', label='table:randr'), include.rownames=FALSE, floating=FALSE,size='\\small')
@
\end{minipage}
\bigskip
\caption {The one per element selection criteria results.}
\label{tbl:onesel}
\end{table*}

\begin{figure*}[t]
<<one.per.sel.sample,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='8in', echo=F, message=F, warn=F,fig.lp="fig:">>=
o.one <- subset(o.processed, grepl('^o[.].*.m[.]red',ind))
ggplot(subset(o.one, values < 100), aes(power, values, fill=interaction(type,power), dodge=type)) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() + facet_wrap(~type) + myopts
@
\caption{The effect of one element selection, All are above 0.98 $R^2$.}
\label{fig:onesel}
\end{figure*}

The values are given in Table~\ref{tbl:onesel}, and its visaulization is in Figure~\ref{fig:onesel}.
% ----------------------------------------------------------------------
% <<oth>>=
% stats.o <- subset(stats.rest, !grepl('^op', operator))
% o.stats.sel.o <- subset(o.f(stats.o), select=sel.colnames)
% r.stats.sel.o <- subset(r.f(stats.o), select=sel.colnames)
% stats.rest <- subset(stats.rest, grepl('^op', operator))
% colnames(o.stats.sel.o) <- new.colnames
% colnames(r.stats.sel.o) <- new.colnames
% @
% 
% \begin{table*}
% \begin{minipage}[h]{0.49\linewidth}
% <<results='asis'>>=
% print(xtable(o.stats.sel.o, caption='Original', label='table:rando'), include.rownames=FALSE, floating=FALSE, size='\\small')
% @
% \end{minipage}
% \hspace{0.5cm}
% \begin{minipage}[h]{0.49\linewidth}
% <<results='asis'>>=
% print(xtable(r.stats.sel.o, caption='Randoop', label='table:randr'), include.rownames=FALSE, floating=FALSE,size='\\small')
% @
% \end{minipage}
% \bigskip
% \caption {Others}
% \label{tbl:osel}
% \end{table*}
% 
% ----------------------------------------------------------------------

\subsection{Operator Selection}
<<opsel>>=
stats.op <- subset(stats.rest, grepl('^(op|TSDL)', operator))
o.stats.sel.op <- subset(o.f(stats.op), select=sel.colnames)
r.stats.sel.op <- subset(r.f(stats.op), select=sel.colnames)
stats.rest <- subset(stats.rest, !grepl('^(op|TSDL)', operator))
colnames(o.stats.sel.op) <- new.colnames
colnames(r.stats.sel.op) <- new.colnames
@

\begin{table*}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(o.stats.sel.op, caption='Original', label='table:rando'), include.rownames=FALSE, floating=FALSE, size='\\small')
@
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[h]{0.49\linewidth}
<<results='asis'>>=
print(xtable(r.stats.sel.op, caption='Randoop', label='table:randr'), include.rownames=FALSE, floating=FALSE,size='\\small')
@
\end{minipage}
\bigskip
\caption {Operator Selection}
\label{tbl:opsel}
\end{table*}

For operator selection, we approximated the operators as far as possible from the research works into the operators exposed by PIT. The results of this are provided in Table~\ref{tbl:opsel}. The subsumption graphs are provided in Figure~\ref{fig:subsumptiono}
% TODO : Check if this makes sense.
\begin{figure*}[t]
\includegraphics[totalheight=6cm]{fig/original.pdf}
\caption{Subsumption Original}
\label{fig:subsumptiono}
\end{figure*}

%\begin{figure*}[t]
%\includegraphics[totalheight=6cm]{fig/randoop.pdf}
%\caption{Subsumption Randoop}
%\label{fig:subsumptionr}
%\end{figure*}[t]

% ----------------------------------------------------------------------
\subsection{Mutant Clustering}
To be added later.
% IGNORED FROM HERE.
\if 0
\subsection{SDL vs Random selection}
\begin{figure*}[t]
<<sdl.1,fig.width=10, fig.height=10, out.width='.95\\linewidth', out.heigth='4in', echo=F, message=F, warn=F,fig.lp="fig:">>=
par(mfrow=c(2,2))
with(o.pit.all, plot(all.cov~TSDL.cov, pch='+', main='Original SDL'))
with(o.pit.all, plot(all.cov~l.1x1_per_line.cov, pch='+', main='Original 1 per line'))
with(r.pit.all, plot(all.cov~TSDL.cov, pch='+', main='Randoop SDl'))
with(r.pit.all, plot(all.cov~l.1x1_per_line.cov, pch='+', main='Randoop 1 per line'))
@
\label{fig:sdl1}
\caption{Statement Deletion vs One per line.}
\end{figure*}
<<results='asis'>>=
oprand <- subset(stats.df,!grepl('^..op', rownames(stats.df)))

oprand.x <- subset(oprand,grepl('^.1x[0-9]+_per_', operator))
oprand.l <- subset(oprand,!grepl('^.1x[0-9]+_per_', operator))
@

\subsection{Correlation Analysis}

$ \mu\{ M_{all}| M_{sample} \} = 0 + \beta_1 \times M{sample}  $

The interesting part is (1) the $\beta_1$ coefficient which tells how much we must multiply the  sampled/selected score to get original score, and $R^2$ which tells us how close the score is.

\subsubsection{sdl.mut.avg and mut.avg}

% <<>>=
% c <- cor(subset(m, select=c(sdl.mut.avg, mut.avg)) , method="kendall", use="pairwise")['sdl.mut.avg', 'mut.avg']
% d <- cor(subset(m, select=c(lrnd.mut.avg, mut.avg)) , method="kendall", use="pairwise")['lrnd.mut.avg', 'mut.avg']
% @
$ \mu_\{M_{all} | M_{sdl}\} = Sexpr{sdl.est} \times M_{sdl} \text{ : } R^2 = Sexpr{sdl.r} \text{,} \tau_{\beta} = Sexpr{c}$

\subsubsection{lrnd.mut.avg and mut.avg}

$ \mu_\{M_{all} | M_{rnd}\} = Sexpr{rnd.est} \times M_{rnd} \text{ : } R^2 = Sexpr{rnd.r} \text{,} \tau_{\beta} = Sexpr{d}$

\subsection{Regression Analysis}
The next question we will tackle is if there exist a difference at all between SDL mutagen and the random sampling. We can perform two statistical tests to answer this question. For the first, we run a simple paired t-test.

%<<>>=
%s <- t.test(lrnd.mut.avg, sdl.mut.avg, paired=T)
%@

The paired t-test failed to sufficient difference between the two distributions with a two-sided p-value of Sexpr{s.p.value}. That is, we do not have sufficient evidence to conclude that the two distributions are different.

The second approch is convoluted (I am a little unclear here.). We try to predict the original mutation score using the mutation score from both sdl and random sampling.
Our full model is

$ \mu_\{M_{all} | M_{sdl}, M_{rnd}\} = 0 + \beta_1 {sdl} + \beta_2 M_{rnd} + \beta_3 M_{sdl} M_{rnd}  $
\begin{small}
% <<results='asis'>>=
% s <- subset(m, select=c(mut.avg,sdl.mut.avg))
% s$type <- 'sdl'
% colnames(s) <- c('mut', 'sample', 'type')
% r <- subset(m, select=c(mut.avg,lrnd.mut.avg))
% r$type <- 'rnd'
% colnames(r) <- c('mut', 'sample', 'type')
% all <- rbind(s, r)
% fm <- with(all, lm(mut ~ sample + type + sample:type))
% sm <- anova(fm)
% print(xtable(sm,caption="My caption"), size="\\small")
% @
\end{small}

We see that both type and sample:type are non-significant for predicting the final model, and sequentially removing them does not change the effectiveness. Hence, the techniques random sampling and statement deletion operator do not have any difference.

\begin{figure*}[t]
% <<tplots, fig.width=5, fig.height=5, out.width='.45\\linewidth', out.heigth='4in', echo=F, message=F, warn=F,fig.lp="fig:">>=
% t_f <- sdl.time~lrnd.time
% plot(t_f, main='SDL ~ RND',pch='*')
% abline(lm(t_f), col='red')
% detach(m)
% @
\caption{Time}
\label{fig:caddrm}
\end{figure*}

\begin{figure*}[t]
\includegraphics[totalheight=6cm]{fig/original.pdf}
\caption{Subsumption Original}
\label{fig:subsumptiono}
\end{figure*}[t]

\begin{figure*}[t]
\includegraphics[totalheight=6cm]{fig/randoop.pdf}
\caption{Subsumption Randoop}
\label{fig:subsumptionr}
\end{figure*}[t]
%% END HERE
\fi
