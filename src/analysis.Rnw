\begin{table*}[!ht]
\caption*{Selective}
<<results='asis'>>=
print(xtable(s.selective.db, caption='Selective', label='table:selective'), include.rownames=T, floating=F, size='\\small',sanitize.text.function=function(x){x})
@
\caption {The operator selection criteria results. }
\label{tbl:lcountl}
\end{table*}

\begin{table*}[!ht]
\caption*{N-Selection}
<<results='asis'>>=
print(xtable(s.nselection.db, caption='N-Selection', label='table:nselection'), include.rownames=T, floating=F, size='\\small',sanitize.text.function=function(x){x})
@
\caption {The n-selection criteria results}
\label{tbl:lcountl}
\end{table*}

\begin{table*}[!ht]
\caption*{Single Operators}
<<results='asis'>>=
print(xtable(s.singles.db, caption='Single Operators', label='table:singles'), include.rownames=T, floating=F, size='\\small',sanitize.text.function=function(x){x})
@
\caption {The single operator selection results}
\label{tbl:lcountl}
\end{table*}

\begin{table*}[!ht]
\caption*{Operator Samples x\%}
<<results='asis'>>=
print(xtable(s.opsample.db, caption='Operator x samples', label='table:opsample'), include.rownames=T, floating=F, size='\\small',sanitize.text.function=function(x){x})
@
\caption {The operator x\% sample criteria results}
\label{tbl:lcountl}
\end{table*}

\begin{table*}[!ht]
\caption*{Element Scoped}
<<results='asis'>>=
print(xtable(s.lmcp.db, caption='Element Scoped', label='table:element'), include.rownames=T, floating=F, size='\\small',sanitize.text.function=function(x){x})
@
\caption {The element based sampling criteria results. }
\label{tbl:lcountl}
\end{table*}

\section{Analysis}
\label{sec:analysis}
For the purpose of comparing different mutation reduction strategies, we
computed the average \textit{test utility}, and \textit{assert utility} of
different strategies.

We use the mutant reduction strategy to select a subset
of mutants from the original set. We then collect all test cases that were
able to kill any of the selected set of mutants. Next we compute the
non-redundant test cases by discarding any test case that can be removed
without letting any of the mutants escape. This is repeated $10$ times,
and the average number of non-redundant test cases are found.

While computing the test cases, we also collect assertion number each
test case has. We compute this as the number of asserts in the test case
incremented by one to account for test cases without any asserts. Thus the
compute both the assertions from non-redundant test cases for the mutant
selection, and also the assertions for the full set of killing test cases
for the mutant selection.

The \textit{test utility} is computed as the difference between the number
of non-redundant test cases the mutant selection achieved and the number of
non-redundant test cases of a random sample of same number of mutants.
The result is reported as a percentage of the non-redundant tests of the random
sample (the baseline).

Similarly \textit{assert utility} of a strategy is computed
