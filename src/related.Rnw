\section{Related Work}
\label{sec:related}
There are several approaches to reducing the cost of mutation analysis.
These were categorized by Offutt and Untch~\cite{offutt2001mutation}
into three approaches: do \textit{fewer}, \textit{smarter}, or \textit{faster}.
The fewer approaches includes selective mutation and mutant sampling;
weak mutation, parallelization of mutation analysis, and space/time trade-offs
are grouped under the umbrella of \textit{do smarter}. Finally
\textit{do faster} approaches include mutant schema generation methods,
code patching etc.

The idea of using a subset of mutants was conceived along with
mutation analysis itself. Budd~\cite{budd1980mutation} and
Acree~\cite{Acree1980} showed that even 10\% sampling can achieve 99\%
accuracy for the final score.  The idea was further investigated by
Mathur~\cite{mathur1991performance}, Wong et
al.~\cite{wong1993mutation,wong1995reducing}, and Offutt et
al.~\cite{offutt1993experimental} using the Mothra~\cite{Mothra}
mutation operators for
Fortran. Mathur~\cite{mathur1991performance,wong1995reducing}
suggested constrained mutation where only two operators
were used.%, which were felt to be better than using the entire set.

% Operator Selection also assumes that fault detection ability of some operators
% are higher than others, and hence some operators should have higher weight
% than others. ~\cite{wong1997comparison}

A number of studies in the past have looked at the relative merits of operator
selection and random sampling criteria, starting with Wong and Mathur in
1995~\cite{wong1995reducing}. They compared x\% selection of each mutant type
with operator selection using just two mutation operators, and found that both
achieved similar accuracy and reduction (80\%). This study was conducted on
five small programs in C and Fortran.

Some studies have tried to find set of \emph{sufficient mutation
operators} that reduce the cost of mutation but maintain correlation
with the full mutation score. Offutt~\cite{offutt1993experimental}
suggested an $n$-selective approach with step-by-step removal of
mutation operators that produced the largest number of mutants.

Mresa et al.\cite{mresa1999efficiency} used the cost of detection of
mutants as a means of selection to define a set of operators. They
found that if very high mutation score (close to 100\%) is required,
x\% selective mutation is better than operator selection, and,
conversely, for lower scores, operator selection would be better if
the cost of mutants is considered.

Barbosa et. al.\cite{barbosa2001toward} provide a set of guidelines
for selecting such mutation operators. Namin et
al.\cite{namin2006finding,siami2008sufficient} formulate the problem
as a variable reduction problem, and apply statistical
approaches. They found a subset of 28 operators out of 108 operators that are
sufficient.

Using only the statement deletion operator was first suggested by
Untch~\cite{untch2009onreduced}, who found that it correlated ($R^2 =
0.97$) with the full mutation score better than other operator
selection methods, while generating the smallest number of mutants.
This was further reinforced by Deng et al.~\cite{deng2013empirical}
who defined deletion for different language elements, and found that
an accuracy of 92\% is achieved while reducing the number of mutants
by 80\%.

Zhang et al.~\cite{zhang2010operator} compares operators based mutant
selection techniques proposed in a set of
papers~\cite{barbosa2001toward,siami2008sufficient,offutt1996anexperimental}
to random mutant sampling.  They find that none of the selection
techniques are superior to random sampling, with the same number of
mutants. They also find that equal mutation sampling is more effective
for larger subjects compared to equal mutagen sampling and the reverse
is true for smaller subjects.
% {\bf ADG:  not having defined mutagen/mtuation sampling this is not easy
% for most readers to understand.  also we switch between "sampling" and
% "random selection" a lot, I tried to make consistent.  }
% RG: Got it.

Recently, Zhang et al.~\cite{zhang2013ase} confirmed that sampling as
few as 5\% of mutants was sufficient for a very high correlation
(99\%) with full mutation score, while sampling even fewer mutants has
good potential for retaining high accuracy. They investigated 8
sampling strategies on top of operator-based mutant selection and
found that sampling strategies based on program components (methods in
particular) performed best.

%The idea is that normal mutation has quadratic complexity on variable references while eliminatng the most
%fecund mutagens (SVR and ASR) achieves linear complexity on program size, while still approximating the full
% mutation score closely. They propose N-selective mutation which avoids N most fertile mutagens.
%Wong \cite{wong1995reducing} compares the effect of x\% mutation selection, and abs/ror constrained mutation.
%According to Wong, this is different from selective mutation in that only the most fecund operators
%are included rather than excluded. He finds that there is no evidence to suggest one over the other.
% Offutt\cite{offutt1993experimental} does not compare the effectivenss of selective mutation with x\% mutation.
% He also defines the concept of {\it operator strength} for an operator, which is defined as the total number
% of mutants that are killed by test data that is generated to kill only the mutants generated by that operator.
% He further posits that the mutagens with greatest strength may be the most useful ones. %(test data generated
% to eliminate variants of one operator may remove the mutants of other kinds too.)
%This is taken up later by Mresa\cite{mresa1999efficiency} et al. who used the cost of detection of mutants as
%a means of selection, and uses it to define another set of operators (san, aor, sdl, ror, uoi). They %also find
%that if very high mutation score close to 100\% is required, x\% selective mutation is better than operator selection,
%and conversely for less stringent scores, operator selection would be better if %const of mutant is considered.


%Offutt\cite{offutt1996anexperimental} following the previous paper\cite{offutt1993experimental} compares the
% effectiveness of selecting different operators. He divides the total operators into operand, operation, and
% statement categories, with es-selective avoiding operands, rs-selective avoiding operations, and re-selective
% avoiding statements, and e-selective only operations. He finds that using only operation based mutation operators
%  (numbering 5) is sufficient for close approximation of full mutation score. He suggests that the reason they are
%   effective is that most statements contain operators. He further posits that another reason is the amount of semantic
%change accomplished by an operator, and perhaps the most interesting ones are those that produce the smallest semantic difference.
% Replacement of Operand , Statement modification, Expression Modification: modify operators, ES-selective : not using
% operand, RS-Selective: not using expression, RE-Selective: not uinsg statement, E-selective : only expression..

%Unch\cite{untch2009onreduced} suggested using a single mutagen statement deletion. He compares the statement deletion
% with other selective mutagen sets, and finds statement deletion operator to provide the best prediction of original mutation score ($R^2 = 0.97$)
%This was carried forward by Deng et al\cite{deng2013empirical}, (according to whom, random sampling was weak when it was
%made low enough for appreciable mutant savings). They realize a mean mutation score of 92\% for adequate test suites with
% SDL alone, and generating a saving of 81\% in the number of mutants, and 41\% fewer equivalent mutants.

Our work is most closely related to that of Zhang et
al.~\cite{zhang2013ase}. We extend the scope of their study with a
much wider range of mutation approches and base our results on a large
set of real-world projects.

% Baseline : x\% from selected set
% MOP : x\% from each mutagen
% for these, it is sampled from operator based selected set.
% PLEm : x\% from inside the same program element.
% PLE + MOP: sample x\% from same mutagen from same element.

% Empirical Evaluation of the Statement Deletion Mutation Operator : Offutt

%\subsection{Execution Reduction}

%Weak mutation, devised by Howden \cite{howden1982weak}, considers a mutant as detected, if
%the states of program after the mutated statement in mutant and the original
%program differ. Several oher studies have refined the idea theoretically \cite{horgan1990weak}and
%observed its effectiveness emperically\cite{offutt1994empirical,Offutt:1991:SWM:120807.120826}.

%Some studies have utlized parallel computation to enhance the execution time of
%the mutation testing \cite{}. Others have used custom built compilers and interpretors \cite{}
%to reduce the overall compile time in mutation testing \cite{}.
